// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/sahidrahman404/gigachad-api/ent/equipment"
	"github.com/sahidrahman404/gigachad-api/ent/exercise"
	"github.com/sahidrahman404/gigachad-api/ent/exercisetype"
	"github.com/sahidrahman404/gigachad-api/ent/musclesgroup"
	"github.com/sahidrahman404/gigachad-api/ent/routine"
	"github.com/sahidrahman404/gigachad-api/ent/routineexercise"
	"github.com/sahidrahman404/gigachad-api/ent/schema/pksuid"
	"github.com/sahidrahman404/gigachad-api/ent/token"
	"github.com/sahidrahman404/gigachad-api/ent/user"
	"github.com/sahidrahman404/gigachad-api/ent/workout"
	"github.com/sahidrahman404/gigachad-api/ent/workoutlog"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[pksuid.ID]
	PageInfo       = entgql.PageInfo[pksuid.ID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// EquipmentEdge is the edge representation of Equipment.
type EquipmentEdge struct {
	Node   *Equipment `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// EquipmentConnection is the connection containing edges to Equipment.
type EquipmentConnection struct {
	Edges      []*EquipmentEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *EquipmentConnection) build(nodes []*Equipment, pager *equipmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Equipment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Equipment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Equipment {
			return nodes[i]
		}
	}
	c.Edges = make([]*EquipmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EquipmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EquipmentPaginateOption enables pagination customization.
type EquipmentPaginateOption func(*equipmentPager) error

// WithEquipmentOrder configures pagination ordering.
func WithEquipmentOrder(order *EquipmentOrder) EquipmentPaginateOption {
	if order == nil {
		order = DefaultEquipmentOrder
	}
	o := *order
	return func(pager *equipmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentFilter configures pagination filter.
func WithEquipmentFilter(filter func(*EquipmentQuery) (*EquipmentQuery, error)) EquipmentPaginateOption {
	return func(pager *equipmentPager) error {
		if filter == nil {
			return errors.New("EquipmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPager struct {
	reverse bool
	order   *EquipmentOrder
	filter  func(*EquipmentQuery) (*EquipmentQuery, error)
}

func newEquipmentPager(opts []EquipmentPaginateOption, reverse bool) (*equipmentPager, error) {
	pager := &equipmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentOrder
	}
	return pager, nil
}

func (p *equipmentPager) applyFilter(query *EquipmentQuery) (*EquipmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPager) toCursor(e *Equipment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *equipmentPager) applyCursors(query *EquipmentQuery, after, before *Cursor) (*EquipmentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEquipmentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *equipmentPager) applyOrder(query *EquipmentQuery) *EquipmentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEquipmentOrder.Field {
		query = query.Order(DefaultEquipmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *equipmentPager) orderExpr(query *EquipmentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEquipmentOrder.Field {
			b.Comma().Ident(DefaultEquipmentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Equipment.
func (e *EquipmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPaginateOption,
) (*EquipmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EquipmentConnection{Edges: []*EquipmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EquipmentOrderField defines the ordering field of Equipment.
type EquipmentOrderField struct {
	// Value extracts the ordering value from the given Equipment.
	Value    func(*Equipment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) equipment.OrderOption
	toCursor func(*Equipment) Cursor
}

// EquipmentOrder defines the ordering of Equipment.
type EquipmentOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *EquipmentOrderField `json:"field"`
}

// DefaultEquipmentOrder is the default ordering of Equipment.
var DefaultEquipmentOrder = &EquipmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EquipmentOrderField{
		Value: func(e *Equipment) (ent.Value, error) {
			return e.ID, nil
		},
		column: equipment.FieldID,
		toTerm: equipment.ByID,
		toCursor: func(e *Equipment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Equipment into EquipmentEdge.
func (e *Equipment) ToEdge(order *EquipmentOrder) *EquipmentEdge {
	if order == nil {
		order = DefaultEquipmentOrder
	}
	return &EquipmentEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ExerciseEdge is the edge representation of Exercise.
type ExerciseEdge struct {
	Node   *Exercise `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExerciseConnection is the connection containing edges to Exercise.
type ExerciseConnection struct {
	Edges      []*ExerciseEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExerciseConnection) build(nodes []*Exercise, pager *exercisePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exercise
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exercise {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exercise {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExerciseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExerciseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExercisePaginateOption enables pagination customization.
type ExercisePaginateOption func(*exercisePager) error

// WithExerciseOrder configures pagination ordering.
func WithExerciseOrder(order *ExerciseOrder) ExercisePaginateOption {
	if order == nil {
		order = DefaultExerciseOrder
	}
	o := *order
	return func(pager *exercisePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExerciseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExerciseFilter configures pagination filter.
func WithExerciseFilter(filter func(*ExerciseQuery) (*ExerciseQuery, error)) ExercisePaginateOption {
	return func(pager *exercisePager) error {
		if filter == nil {
			return errors.New("ExerciseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exercisePager struct {
	reverse bool
	order   *ExerciseOrder
	filter  func(*ExerciseQuery) (*ExerciseQuery, error)
}

func newExercisePager(opts []ExercisePaginateOption, reverse bool) (*exercisePager, error) {
	pager := &exercisePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExerciseOrder
	}
	return pager, nil
}

func (p *exercisePager) applyFilter(query *ExerciseQuery) (*ExerciseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exercisePager) toCursor(e *Exercise) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *exercisePager) applyCursors(query *ExerciseQuery, after, before *Cursor) (*ExerciseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExerciseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *exercisePager) applyOrder(query *ExerciseQuery) *ExerciseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExerciseOrder.Field {
		query = query.Order(DefaultExerciseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *exercisePager) orderExpr(query *ExerciseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExerciseOrder.Field {
			b.Comma().Ident(DefaultExerciseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exercise.
func (e *ExerciseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExercisePaginateOption,
) (*ExerciseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExercisePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &ExerciseConnection{Edges: []*ExerciseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExerciseOrderField defines the ordering field of Exercise.
type ExerciseOrderField struct {
	// Value extracts the ordering value from the given Exercise.
	Value    func(*Exercise) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) exercise.OrderOption
	toCursor func(*Exercise) Cursor
}

// ExerciseOrder defines the ordering of Exercise.
type ExerciseOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExerciseOrderField `json:"field"`
}

// DefaultExerciseOrder is the default ordering of Exercise.
var DefaultExerciseOrder = &ExerciseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExerciseOrderField{
		Value: func(e *Exercise) (ent.Value, error) {
			return e.ID, nil
		},
		column: exercise.FieldID,
		toTerm: exercise.ByID,
		toCursor: func(e *Exercise) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Exercise into ExerciseEdge.
func (e *Exercise) ToEdge(order *ExerciseOrder) *ExerciseEdge {
	if order == nil {
		order = DefaultExerciseOrder
	}
	return &ExerciseEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ExerciseTypeEdge is the edge representation of ExerciseType.
type ExerciseTypeEdge struct {
	Node   *ExerciseType `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ExerciseTypeConnection is the connection containing edges to ExerciseType.
type ExerciseTypeConnection struct {
	Edges      []*ExerciseTypeEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ExerciseTypeConnection) build(nodes []*ExerciseType, pager *exercisetypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ExerciseType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ExerciseType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ExerciseType {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExerciseTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExerciseTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExerciseTypePaginateOption enables pagination customization.
type ExerciseTypePaginateOption func(*exercisetypePager) error

// WithExerciseTypeOrder configures pagination ordering.
func WithExerciseTypeOrder(order *ExerciseTypeOrder) ExerciseTypePaginateOption {
	if order == nil {
		order = DefaultExerciseTypeOrder
	}
	o := *order
	return func(pager *exercisetypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExerciseTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExerciseTypeFilter configures pagination filter.
func WithExerciseTypeFilter(filter func(*ExerciseTypeQuery) (*ExerciseTypeQuery, error)) ExerciseTypePaginateOption {
	return func(pager *exercisetypePager) error {
		if filter == nil {
			return errors.New("ExerciseTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exercisetypePager struct {
	reverse bool
	order   *ExerciseTypeOrder
	filter  func(*ExerciseTypeQuery) (*ExerciseTypeQuery, error)
}

func newExerciseTypePager(opts []ExerciseTypePaginateOption, reverse bool) (*exercisetypePager, error) {
	pager := &exercisetypePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExerciseTypeOrder
	}
	return pager, nil
}

func (p *exercisetypePager) applyFilter(query *ExerciseTypeQuery) (*ExerciseTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exercisetypePager) toCursor(et *ExerciseType) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *exercisetypePager) applyCursors(query *ExerciseTypeQuery, after, before *Cursor) (*ExerciseTypeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExerciseTypeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *exercisetypePager) applyOrder(query *ExerciseTypeQuery) *ExerciseTypeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExerciseTypeOrder.Field {
		query = query.Order(DefaultExerciseTypeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *exercisetypePager) orderExpr(query *ExerciseTypeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExerciseTypeOrder.Field {
			b.Comma().Ident(DefaultExerciseTypeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ExerciseType.
func (et *ExerciseTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExerciseTypePaginateOption,
) (*ExerciseTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExerciseTypePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &ExerciseTypeConnection{Edges: []*ExerciseTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := et.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if et, err = pager.applyCursors(et, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	et = pager.applyOrder(et)
	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExerciseTypeOrderField defines the ordering field of ExerciseType.
type ExerciseTypeOrderField struct {
	// Value extracts the ordering value from the given ExerciseType.
	Value    func(*ExerciseType) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) exercisetype.OrderOption
	toCursor func(*ExerciseType) Cursor
}

// ExerciseTypeOrder defines the ordering of ExerciseType.
type ExerciseTypeOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ExerciseTypeOrderField `json:"field"`
}

// DefaultExerciseTypeOrder is the default ordering of ExerciseType.
var DefaultExerciseTypeOrder = &ExerciseTypeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExerciseTypeOrderField{
		Value: func(et *ExerciseType) (ent.Value, error) {
			return et.ID, nil
		},
		column: exercisetype.FieldID,
		toTerm: exercisetype.ByID,
		toCursor: func(et *ExerciseType) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts ExerciseType into ExerciseTypeEdge.
func (et *ExerciseType) ToEdge(order *ExerciseTypeOrder) *ExerciseTypeEdge {
	if order == nil {
		order = DefaultExerciseTypeOrder
	}
	return &ExerciseTypeEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// MusclesGroupEdge is the edge representation of MusclesGroup.
type MusclesGroupEdge struct {
	Node   *MusclesGroup `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// MusclesGroupConnection is the connection containing edges to MusclesGroup.
type MusclesGroupConnection struct {
	Edges      []*MusclesGroupEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *MusclesGroupConnection) build(nodes []*MusclesGroup, pager *musclesgroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MusclesGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MusclesGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MusclesGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*MusclesGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MusclesGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MusclesGroupPaginateOption enables pagination customization.
type MusclesGroupPaginateOption func(*musclesgroupPager) error

// WithMusclesGroupOrder configures pagination ordering.
func WithMusclesGroupOrder(order *MusclesGroupOrder) MusclesGroupPaginateOption {
	if order == nil {
		order = DefaultMusclesGroupOrder
	}
	o := *order
	return func(pager *musclesgroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMusclesGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMusclesGroupFilter configures pagination filter.
func WithMusclesGroupFilter(filter func(*MusclesGroupQuery) (*MusclesGroupQuery, error)) MusclesGroupPaginateOption {
	return func(pager *musclesgroupPager) error {
		if filter == nil {
			return errors.New("MusclesGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type musclesgroupPager struct {
	reverse bool
	order   *MusclesGroupOrder
	filter  func(*MusclesGroupQuery) (*MusclesGroupQuery, error)
}

func newMusclesGroupPager(opts []MusclesGroupPaginateOption, reverse bool) (*musclesgroupPager, error) {
	pager := &musclesgroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMusclesGroupOrder
	}
	return pager, nil
}

func (p *musclesgroupPager) applyFilter(query *MusclesGroupQuery) (*MusclesGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *musclesgroupPager) toCursor(mg *MusclesGroup) Cursor {
	return p.order.Field.toCursor(mg)
}

func (p *musclesgroupPager) applyCursors(query *MusclesGroupQuery, after, before *Cursor) (*MusclesGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMusclesGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *musclesgroupPager) applyOrder(query *MusclesGroupQuery) *MusclesGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMusclesGroupOrder.Field {
		query = query.Order(DefaultMusclesGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *musclesgroupPager) orderExpr(query *MusclesGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMusclesGroupOrder.Field {
			b.Comma().Ident(DefaultMusclesGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MusclesGroup.
func (mg *MusclesGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MusclesGroupPaginateOption,
) (*MusclesGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMusclesGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mg, err = pager.applyFilter(mg); err != nil {
		return nil, err
	}
	conn := &MusclesGroupConnection{Edges: []*MusclesGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mg, err = pager.applyCursors(mg, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		mg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mg = pager.applyOrder(mg)
	nodes, err := mg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MusclesGroupOrderField defines the ordering field of MusclesGroup.
type MusclesGroupOrderField struct {
	// Value extracts the ordering value from the given MusclesGroup.
	Value    func(*MusclesGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) musclesgroup.OrderOption
	toCursor func(*MusclesGroup) Cursor
}

// MusclesGroupOrder defines the ordering of MusclesGroup.
type MusclesGroupOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *MusclesGroupOrderField `json:"field"`
}

// DefaultMusclesGroupOrder is the default ordering of MusclesGroup.
var DefaultMusclesGroupOrder = &MusclesGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MusclesGroupOrderField{
		Value: func(mg *MusclesGroup) (ent.Value, error) {
			return mg.ID, nil
		},
		column: musclesgroup.FieldID,
		toTerm: musclesgroup.ByID,
		toCursor: func(mg *MusclesGroup) Cursor {
			return Cursor{ID: mg.ID}
		},
	},
}

// ToEdge converts MusclesGroup into MusclesGroupEdge.
func (mg *MusclesGroup) ToEdge(order *MusclesGroupOrder) *MusclesGroupEdge {
	if order == nil {
		order = DefaultMusclesGroupOrder
	}
	return &MusclesGroupEdge{
		Node:   mg,
		Cursor: order.Field.toCursor(mg),
	}
}

// RoutineEdge is the edge representation of Routine.
type RoutineEdge struct {
	Node   *Routine `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// RoutineConnection is the connection containing edges to Routine.
type RoutineConnection struct {
	Edges      []*RoutineEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *RoutineConnection) build(nodes []*Routine, pager *routinePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Routine
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Routine {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Routine {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoutineEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoutineEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RoutinePaginateOption enables pagination customization.
type RoutinePaginateOption func(*routinePager) error

// WithRoutineOrder configures pagination ordering.
func WithRoutineOrder(order *RoutineOrder) RoutinePaginateOption {
	if order == nil {
		order = DefaultRoutineOrder
	}
	o := *order
	return func(pager *routinePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoutineOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoutineFilter configures pagination filter.
func WithRoutineFilter(filter func(*RoutineQuery) (*RoutineQuery, error)) RoutinePaginateOption {
	return func(pager *routinePager) error {
		if filter == nil {
			return errors.New("RoutineQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routinePager struct {
	reverse bool
	order   *RoutineOrder
	filter  func(*RoutineQuery) (*RoutineQuery, error)
}

func newRoutinePager(opts []RoutinePaginateOption, reverse bool) (*routinePager, error) {
	pager := &routinePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoutineOrder
	}
	return pager, nil
}

func (p *routinePager) applyFilter(query *RoutineQuery) (*RoutineQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routinePager) toCursor(r *Routine) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *routinePager) applyCursors(query *RoutineQuery, after, before *Cursor) (*RoutineQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRoutineOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *routinePager) applyOrder(query *RoutineQuery) *RoutineQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRoutineOrder.Field {
		query = query.Order(DefaultRoutineOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *routinePager) orderExpr(query *RoutineQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoutineOrder.Field {
			b.Comma().Ident(DefaultRoutineOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Routine.
func (r *RoutineQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RoutinePaginateOption,
) (*RoutineConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRoutinePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RoutineConnection{Edges: []*RoutineEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := r.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RoutineOrderField defines the ordering field of Routine.
type RoutineOrderField struct {
	// Value extracts the ordering value from the given Routine.
	Value    func(*Routine) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) routine.OrderOption
	toCursor func(*Routine) Cursor
}

// RoutineOrder defines the ordering of Routine.
type RoutineOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *RoutineOrderField `json:"field"`
}

// DefaultRoutineOrder is the default ordering of Routine.
var DefaultRoutineOrder = &RoutineOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RoutineOrderField{
		Value: func(r *Routine) (ent.Value, error) {
			return r.ID, nil
		},
		column: routine.FieldID,
		toTerm: routine.ByID,
		toCursor: func(r *Routine) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Routine into RoutineEdge.
func (r *Routine) ToEdge(order *RoutineOrder) *RoutineEdge {
	if order == nil {
		order = DefaultRoutineOrder
	}
	return &RoutineEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RoutineExerciseEdge is the edge representation of RoutineExercise.
type RoutineExerciseEdge struct {
	Node   *RoutineExercise `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// RoutineExerciseConnection is the connection containing edges to RoutineExercise.
type RoutineExerciseConnection struct {
	Edges      []*RoutineExerciseEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *RoutineExerciseConnection) build(nodes []*RoutineExercise, pager *routineexercisePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RoutineExercise
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RoutineExercise {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RoutineExercise {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoutineExerciseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoutineExerciseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RoutineExercisePaginateOption enables pagination customization.
type RoutineExercisePaginateOption func(*routineexercisePager) error

// WithRoutineExerciseOrder configures pagination ordering.
func WithRoutineExerciseOrder(order *RoutineExerciseOrder) RoutineExercisePaginateOption {
	if order == nil {
		order = DefaultRoutineExerciseOrder
	}
	o := *order
	return func(pager *routineexercisePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoutineExerciseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoutineExerciseFilter configures pagination filter.
func WithRoutineExerciseFilter(filter func(*RoutineExerciseQuery) (*RoutineExerciseQuery, error)) RoutineExercisePaginateOption {
	return func(pager *routineexercisePager) error {
		if filter == nil {
			return errors.New("RoutineExerciseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routineexercisePager struct {
	reverse bool
	order   *RoutineExerciseOrder
	filter  func(*RoutineExerciseQuery) (*RoutineExerciseQuery, error)
}

func newRoutineExercisePager(opts []RoutineExercisePaginateOption, reverse bool) (*routineexercisePager, error) {
	pager := &routineexercisePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoutineExerciseOrder
	}
	return pager, nil
}

func (p *routineexercisePager) applyFilter(query *RoutineExerciseQuery) (*RoutineExerciseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routineexercisePager) toCursor(re *RoutineExercise) Cursor {
	return p.order.Field.toCursor(re)
}

func (p *routineexercisePager) applyCursors(query *RoutineExerciseQuery, after, before *Cursor) (*RoutineExerciseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRoutineExerciseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *routineexercisePager) applyOrder(query *RoutineExerciseQuery) *RoutineExerciseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRoutineExerciseOrder.Field {
		query = query.Order(DefaultRoutineExerciseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *routineexercisePager) orderExpr(query *RoutineExerciseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoutineExerciseOrder.Field {
			b.Comma().Ident(DefaultRoutineExerciseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RoutineExercise.
func (re *RoutineExerciseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RoutineExercisePaginateOption,
) (*RoutineExerciseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRoutineExercisePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if re, err = pager.applyFilter(re); err != nil {
		return nil, err
	}
	conn := &RoutineExerciseConnection{Edges: []*RoutineExerciseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := re.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if re, err = pager.applyCursors(re, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		re.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := re.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	re = pager.applyOrder(re)
	nodes, err := re.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RoutineExerciseOrderField defines the ordering field of RoutineExercise.
type RoutineExerciseOrderField struct {
	// Value extracts the ordering value from the given RoutineExercise.
	Value    func(*RoutineExercise) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) routineexercise.OrderOption
	toCursor func(*RoutineExercise) Cursor
}

// RoutineExerciseOrder defines the ordering of RoutineExercise.
type RoutineExerciseOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *RoutineExerciseOrderField `json:"field"`
}

// DefaultRoutineExerciseOrder is the default ordering of RoutineExercise.
var DefaultRoutineExerciseOrder = &RoutineExerciseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RoutineExerciseOrderField{
		Value: func(re *RoutineExercise) (ent.Value, error) {
			return re.ID, nil
		},
		column: routineexercise.FieldID,
		toTerm: routineexercise.ByID,
		toCursor: func(re *RoutineExercise) Cursor {
			return Cursor{ID: re.ID}
		},
	},
}

// ToEdge converts RoutineExercise into RoutineExerciseEdge.
func (re *RoutineExercise) ToEdge(order *RoutineExerciseOrder) *RoutineExerciseEdge {
	if order == nil {
		order = DefaultRoutineExerciseOrder
	}
	return &RoutineExerciseEdge{
		Node:   re,
		Cursor: order.Field.toCursor(re),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	reverse bool
	order   *TokenOrder
	filter  func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption, reverse bool) (*tokenPager, error) {
	pager := &tokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) (*TokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tokenPager) applyOrder(query *TokenQuery) *TokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(DefaultTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tokenPager) orderExpr(query *TokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	// Value extracts the ordering value from the given Token.
	Value    func(*Token) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) token.OrderOption
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.ID, nil
		},
		column: token.FieldID,
		toTerm: token.ByID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// WorkoutEdge is the edge representation of Workout.
type WorkoutEdge struct {
	Node   *Workout `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// WorkoutConnection is the connection containing edges to Workout.
type WorkoutConnection struct {
	Edges      []*WorkoutEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *WorkoutConnection) build(nodes []*Workout, pager *workoutPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Workout
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workout {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workout {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkoutEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkoutEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkoutPaginateOption enables pagination customization.
type WorkoutPaginateOption func(*workoutPager) error

// WithWorkoutOrder configures pagination ordering.
func WithWorkoutOrder(order *WorkoutOrder) WorkoutPaginateOption {
	if order == nil {
		order = DefaultWorkoutOrder
	}
	o := *order
	return func(pager *workoutPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkoutOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkoutFilter configures pagination filter.
func WithWorkoutFilter(filter func(*WorkoutQuery) (*WorkoutQuery, error)) WorkoutPaginateOption {
	return func(pager *workoutPager) error {
		if filter == nil {
			return errors.New("WorkoutQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workoutPager struct {
	reverse bool
	order   *WorkoutOrder
	filter  func(*WorkoutQuery) (*WorkoutQuery, error)
}

func newWorkoutPager(opts []WorkoutPaginateOption, reverse bool) (*workoutPager, error) {
	pager := &workoutPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkoutOrder
	}
	return pager, nil
}

func (p *workoutPager) applyFilter(query *WorkoutQuery) (*WorkoutQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workoutPager) toCursor(w *Workout) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *workoutPager) applyCursors(query *WorkoutQuery, after, before *Cursor) (*WorkoutQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkoutOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workoutPager) applyOrder(query *WorkoutQuery) *WorkoutQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkoutOrder.Field {
		query = query.Order(DefaultWorkoutOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workoutPager) orderExpr(query *WorkoutQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkoutOrder.Field {
			b.Comma().Ident(DefaultWorkoutOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Workout.
func (w *WorkoutQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkoutPaginateOption,
) (*WorkoutConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkoutPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WorkoutConnection{Edges: []*WorkoutEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := w.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkoutOrderField defines the ordering field of Workout.
type WorkoutOrderField struct {
	// Value extracts the ordering value from the given Workout.
	Value    func(*Workout) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workout.OrderOption
	toCursor func(*Workout) Cursor
}

// WorkoutOrder defines the ordering of Workout.
type WorkoutOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *WorkoutOrderField `json:"field"`
}

// DefaultWorkoutOrder is the default ordering of Workout.
var DefaultWorkoutOrder = &WorkoutOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkoutOrderField{
		Value: func(w *Workout) (ent.Value, error) {
			return w.ID, nil
		},
		column: workout.FieldID,
		toTerm: workout.ByID,
		toCursor: func(w *Workout) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workout into WorkoutEdge.
func (w *Workout) ToEdge(order *WorkoutOrder) *WorkoutEdge {
	if order == nil {
		order = DefaultWorkoutOrder
	}
	return &WorkoutEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WorkoutLogEdge is the edge representation of WorkoutLog.
type WorkoutLogEdge struct {
	Node   *WorkoutLog `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// WorkoutLogConnection is the connection containing edges to WorkoutLog.
type WorkoutLogConnection struct {
	Edges      []*WorkoutLogEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *WorkoutLogConnection) build(nodes []*WorkoutLog, pager *workoutlogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WorkoutLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkoutLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkoutLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkoutLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkoutLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkoutLogPaginateOption enables pagination customization.
type WorkoutLogPaginateOption func(*workoutlogPager) error

// WithWorkoutLogOrder configures pagination ordering.
func WithWorkoutLogOrder(order *WorkoutLogOrder) WorkoutLogPaginateOption {
	if order == nil {
		order = DefaultWorkoutLogOrder
	}
	o := *order
	return func(pager *workoutlogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkoutLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkoutLogFilter configures pagination filter.
func WithWorkoutLogFilter(filter func(*WorkoutLogQuery) (*WorkoutLogQuery, error)) WorkoutLogPaginateOption {
	return func(pager *workoutlogPager) error {
		if filter == nil {
			return errors.New("WorkoutLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workoutlogPager struct {
	reverse bool
	order   *WorkoutLogOrder
	filter  func(*WorkoutLogQuery) (*WorkoutLogQuery, error)
}

func newWorkoutLogPager(opts []WorkoutLogPaginateOption, reverse bool) (*workoutlogPager, error) {
	pager := &workoutlogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkoutLogOrder
	}
	return pager, nil
}

func (p *workoutlogPager) applyFilter(query *WorkoutLogQuery) (*WorkoutLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workoutlogPager) toCursor(wl *WorkoutLog) Cursor {
	return p.order.Field.toCursor(wl)
}

func (p *workoutlogPager) applyCursors(query *WorkoutLogQuery, after, before *Cursor) (*WorkoutLogQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkoutLogOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workoutlogPager) applyOrder(query *WorkoutLogQuery) *WorkoutLogQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkoutLogOrder.Field {
		query = query.Order(DefaultWorkoutLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workoutlogPager) orderExpr(query *WorkoutLogQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkoutLogOrder.Field {
			b.Comma().Ident(DefaultWorkoutLogOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkoutLog.
func (wl *WorkoutLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkoutLogPaginateOption,
) (*WorkoutLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkoutLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wl, err = pager.applyFilter(wl); err != nil {
		return nil, err
	}
	conn := &WorkoutLogConnection{Edges: []*WorkoutLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := wl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wl, err = pager.applyCursors(wl, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wl.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wl = pager.applyOrder(wl)
	nodes, err := wl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkoutLogOrderField defines the ordering field of WorkoutLog.
type WorkoutLogOrderField struct {
	// Value extracts the ordering value from the given WorkoutLog.
	Value    func(*WorkoutLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workoutlog.OrderOption
	toCursor func(*WorkoutLog) Cursor
}

// WorkoutLogOrder defines the ordering of WorkoutLog.
type WorkoutLogOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *WorkoutLogOrderField `json:"field"`
}

// DefaultWorkoutLogOrder is the default ordering of WorkoutLog.
var DefaultWorkoutLogOrder = &WorkoutLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkoutLogOrderField{
		Value: func(wl *WorkoutLog) (ent.Value, error) {
			return wl.ID, nil
		},
		column: workoutlog.FieldID,
		toTerm: workoutlog.ByID,
		toCursor: func(wl *WorkoutLog) Cursor {
			return Cursor{ID: wl.ID}
		},
	},
}

// ToEdge converts WorkoutLog into WorkoutLogEdge.
func (wl *WorkoutLog) ToEdge(order *WorkoutLogOrder) *WorkoutLogEdge {
	if order == nil {
		order = DefaultWorkoutLogOrder
	}
	return &WorkoutLogEdge{
		Node:   wl,
		Cursor: order.Field.toCursor(wl),
	}
}
