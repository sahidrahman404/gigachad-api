// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/sahidrahman404/gigachad-api/ent/equipment"
	"github.com/sahidrahman404/gigachad-api/ent/exercise"
	"github.com/sahidrahman404/gigachad-api/ent/exercisetype"
	"github.com/sahidrahman404/gigachad-api/ent/musclesgroup"
	"github.com/sahidrahman404/gigachad-api/ent/routine"
	"github.com/sahidrahman404/gigachad-api/ent/routineexercise"
	"github.com/sahidrahman404/gigachad-api/ent/token"
	"github.com/sahidrahman404/gigachad-api/ent/user"
	"github.com/sahidrahman404/gigachad-api/ent/workout"
	"github.com/sahidrahman404/gigachad-api/ent/workoutlog"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    string `msgpack:"i"`
	Value Value  `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// EquipmentEdge is the edge representation of Equipment.
type EquipmentEdge struct {
	Node   *Equipment `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// EquipmentConnection is the connection containing edges to Equipment.
type EquipmentConnection struct {
	Edges      []*EquipmentEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *EquipmentConnection) build(nodes []*Equipment, pager *equipmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Equipment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Equipment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Equipment {
			return nodes[i]
		}
	}
	c.Edges = make([]*EquipmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EquipmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EquipmentPaginateOption enables pagination customization.
type EquipmentPaginateOption func(*equipmentPager) error

// WithEquipmentOrder configures pagination ordering.
func WithEquipmentOrder(order *EquipmentOrder) EquipmentPaginateOption {
	if order == nil {
		order = DefaultEquipmentOrder
	}
	o := *order
	return func(pager *equipmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEquipmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEquipmentFilter configures pagination filter.
func WithEquipmentFilter(filter func(*EquipmentQuery) (*EquipmentQuery, error)) EquipmentPaginateOption {
	return func(pager *equipmentPager) error {
		if filter == nil {
			return errors.New("EquipmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type equipmentPager struct {
	order  *EquipmentOrder
	filter func(*EquipmentQuery) (*EquipmentQuery, error)
}

func newEquipmentPager(opts []EquipmentPaginateOption) (*equipmentPager, error) {
	pager := &equipmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEquipmentOrder
	}
	return pager, nil
}

func (p *equipmentPager) applyFilter(query *EquipmentQuery) (*EquipmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *equipmentPager) toCursor(e *Equipment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *equipmentPager) applyCursors(query *EquipmentQuery, after, before *Cursor) *EquipmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEquipmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *equipmentPager) applyOrder(query *EquipmentQuery, reverse bool) *EquipmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEquipmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEquipmentOrder.Field.field))
	}
	return query
}

func (p *equipmentPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEquipmentOrder.Field {
			b.Comma().Ident(DefaultEquipmentOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Equipment.
func (e *EquipmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EquipmentPaginateOption,
) (*EquipmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEquipmentPager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EquipmentConnection{Edges: []*EquipmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EquipmentOrderField defines the ordering field of Equipment.
type EquipmentOrderField struct {
	field    string
	toCursor func(*Equipment) Cursor
}

// EquipmentOrder defines the ordering of Equipment.
type EquipmentOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *EquipmentOrderField `json:"field"`
}

// DefaultEquipmentOrder is the default ordering of Equipment.
var DefaultEquipmentOrder = &EquipmentOrder{
	Direction: OrderDirectionAsc,
	Field: &EquipmentOrderField{
		field: equipment.FieldID,
		toCursor: func(e *Equipment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Equipment into EquipmentEdge.
func (e *Equipment) ToEdge(order *EquipmentOrder) *EquipmentEdge {
	if order == nil {
		order = DefaultEquipmentOrder
	}
	return &EquipmentEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ExerciseEdge is the edge representation of Exercise.
type ExerciseEdge struct {
	Node   *Exercise `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExerciseConnection is the connection containing edges to Exercise.
type ExerciseConnection struct {
	Edges      []*ExerciseEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExerciseConnection) build(nodes []*Exercise, pager *exercisePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exercise
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exercise {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exercise {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExerciseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExerciseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExercisePaginateOption enables pagination customization.
type ExercisePaginateOption func(*exercisePager) error

// WithExerciseOrder configures pagination ordering.
func WithExerciseOrder(order *ExerciseOrder) ExercisePaginateOption {
	if order == nil {
		order = DefaultExerciseOrder
	}
	o := *order
	return func(pager *exercisePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExerciseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExerciseFilter configures pagination filter.
func WithExerciseFilter(filter func(*ExerciseQuery) (*ExerciseQuery, error)) ExercisePaginateOption {
	return func(pager *exercisePager) error {
		if filter == nil {
			return errors.New("ExerciseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exercisePager struct {
	order  *ExerciseOrder
	filter func(*ExerciseQuery) (*ExerciseQuery, error)
}

func newExercisePager(opts []ExercisePaginateOption) (*exercisePager, error) {
	pager := &exercisePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExerciseOrder
	}
	return pager, nil
}

func (p *exercisePager) applyFilter(query *ExerciseQuery) (*ExerciseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exercisePager) toCursor(e *Exercise) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *exercisePager) applyCursors(query *ExerciseQuery, after, before *Cursor) *ExerciseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExerciseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exercisePager) applyOrder(query *ExerciseQuery, reverse bool) *ExerciseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExerciseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExerciseOrder.Field.field))
	}
	return query
}

func (p *exercisePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExerciseOrder.Field {
			b.Comma().Ident(DefaultExerciseOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exercise.
func (e *ExerciseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExercisePaginateOption,
) (*ExerciseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExercisePager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &ExerciseConnection{Edges: []*ExerciseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExerciseOrderField defines the ordering field of Exercise.
type ExerciseOrderField struct {
	field    string
	toCursor func(*Exercise) Cursor
}

// ExerciseOrder defines the ordering of Exercise.
type ExerciseOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExerciseOrderField `json:"field"`
}

// DefaultExerciseOrder is the default ordering of Exercise.
var DefaultExerciseOrder = &ExerciseOrder{
	Direction: OrderDirectionAsc,
	Field: &ExerciseOrderField{
		field: exercise.FieldID,
		toCursor: func(e *Exercise) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Exercise into ExerciseEdge.
func (e *Exercise) ToEdge(order *ExerciseOrder) *ExerciseEdge {
	if order == nil {
		order = DefaultExerciseOrder
	}
	return &ExerciseEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ExerciseTypeEdge is the edge representation of ExerciseType.
type ExerciseTypeEdge struct {
	Node   *ExerciseType `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ExerciseTypeConnection is the connection containing edges to ExerciseType.
type ExerciseTypeConnection struct {
	Edges      []*ExerciseTypeEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ExerciseTypeConnection) build(nodes []*ExerciseType, pager *exercisetypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ExerciseType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ExerciseType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ExerciseType {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExerciseTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExerciseTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExerciseTypePaginateOption enables pagination customization.
type ExerciseTypePaginateOption func(*exercisetypePager) error

// WithExerciseTypeOrder configures pagination ordering.
func WithExerciseTypeOrder(order *ExerciseTypeOrder) ExerciseTypePaginateOption {
	if order == nil {
		order = DefaultExerciseTypeOrder
	}
	o := *order
	return func(pager *exercisetypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExerciseTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExerciseTypeFilter configures pagination filter.
func WithExerciseTypeFilter(filter func(*ExerciseTypeQuery) (*ExerciseTypeQuery, error)) ExerciseTypePaginateOption {
	return func(pager *exercisetypePager) error {
		if filter == nil {
			return errors.New("ExerciseTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exercisetypePager struct {
	order  *ExerciseTypeOrder
	filter func(*ExerciseTypeQuery) (*ExerciseTypeQuery, error)
}

func newExerciseTypePager(opts []ExerciseTypePaginateOption) (*exercisetypePager, error) {
	pager := &exercisetypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExerciseTypeOrder
	}
	return pager, nil
}

func (p *exercisetypePager) applyFilter(query *ExerciseTypeQuery) (*ExerciseTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exercisetypePager) toCursor(et *ExerciseType) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *exercisetypePager) applyCursors(query *ExerciseTypeQuery, after, before *Cursor) *ExerciseTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExerciseTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exercisetypePager) applyOrder(query *ExerciseTypeQuery, reverse bool) *ExerciseTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExerciseTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExerciseTypeOrder.Field.field))
	}
	return query
}

func (p *exercisetypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExerciseTypeOrder.Field {
			b.Comma().Ident(DefaultExerciseTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ExerciseType.
func (et *ExerciseTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExerciseTypePaginateOption,
) (*ExerciseTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExerciseTypePager(opts)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &ExerciseTypeConnection{Edges: []*ExerciseTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = et.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	et = pager.applyCursors(et, after, before)
	et = pager.applyOrder(et, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExerciseTypeOrderField defines the ordering field of ExerciseType.
type ExerciseTypeOrderField struct {
	field    string
	toCursor func(*ExerciseType) Cursor
}

// ExerciseTypeOrder defines the ordering of ExerciseType.
type ExerciseTypeOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ExerciseTypeOrderField `json:"field"`
}

// DefaultExerciseTypeOrder is the default ordering of ExerciseType.
var DefaultExerciseTypeOrder = &ExerciseTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &ExerciseTypeOrderField{
		field: exercisetype.FieldID,
		toCursor: func(et *ExerciseType) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts ExerciseType into ExerciseTypeEdge.
func (et *ExerciseType) ToEdge(order *ExerciseTypeOrder) *ExerciseTypeEdge {
	if order == nil {
		order = DefaultExerciseTypeOrder
	}
	return &ExerciseTypeEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// MusclesGroupEdge is the edge representation of MusclesGroup.
type MusclesGroupEdge struct {
	Node   *MusclesGroup `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// MusclesGroupConnection is the connection containing edges to MusclesGroup.
type MusclesGroupConnection struct {
	Edges      []*MusclesGroupEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *MusclesGroupConnection) build(nodes []*MusclesGroup, pager *musclesgroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *MusclesGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *MusclesGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *MusclesGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*MusclesGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MusclesGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MusclesGroupPaginateOption enables pagination customization.
type MusclesGroupPaginateOption func(*musclesgroupPager) error

// WithMusclesGroupOrder configures pagination ordering.
func WithMusclesGroupOrder(order *MusclesGroupOrder) MusclesGroupPaginateOption {
	if order == nil {
		order = DefaultMusclesGroupOrder
	}
	o := *order
	return func(pager *musclesgroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMusclesGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMusclesGroupFilter configures pagination filter.
func WithMusclesGroupFilter(filter func(*MusclesGroupQuery) (*MusclesGroupQuery, error)) MusclesGroupPaginateOption {
	return func(pager *musclesgroupPager) error {
		if filter == nil {
			return errors.New("MusclesGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type musclesgroupPager struct {
	order  *MusclesGroupOrder
	filter func(*MusclesGroupQuery) (*MusclesGroupQuery, error)
}

func newMusclesGroupPager(opts []MusclesGroupPaginateOption) (*musclesgroupPager, error) {
	pager := &musclesgroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMusclesGroupOrder
	}
	return pager, nil
}

func (p *musclesgroupPager) applyFilter(query *MusclesGroupQuery) (*MusclesGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *musclesgroupPager) toCursor(mg *MusclesGroup) Cursor {
	return p.order.Field.toCursor(mg)
}

func (p *musclesgroupPager) applyCursors(query *MusclesGroupQuery, after, before *Cursor) *MusclesGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMusclesGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *musclesgroupPager) applyOrder(query *MusclesGroupQuery, reverse bool) *MusclesGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMusclesGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMusclesGroupOrder.Field.field))
	}
	return query
}

func (p *musclesgroupPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMusclesGroupOrder.Field {
			b.Comma().Ident(DefaultMusclesGroupOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to MusclesGroup.
func (mg *MusclesGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MusclesGroupPaginateOption,
) (*MusclesGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMusclesGroupPager(opts)
	if err != nil {
		return nil, err
	}
	if mg, err = pager.applyFilter(mg); err != nil {
		return nil, err
	}
	conn := &MusclesGroupConnection{Edges: []*MusclesGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = mg.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	mg = pager.applyCursors(mg, after, before)
	mg = pager.applyOrder(mg, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		mg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := mg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MusclesGroupOrderField defines the ordering field of MusclesGroup.
type MusclesGroupOrderField struct {
	field    string
	toCursor func(*MusclesGroup) Cursor
}

// MusclesGroupOrder defines the ordering of MusclesGroup.
type MusclesGroupOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *MusclesGroupOrderField `json:"field"`
}

// DefaultMusclesGroupOrder is the default ordering of MusclesGroup.
var DefaultMusclesGroupOrder = &MusclesGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &MusclesGroupOrderField{
		field: musclesgroup.FieldID,
		toCursor: func(mg *MusclesGroup) Cursor {
			return Cursor{ID: mg.ID}
		},
	},
}

// ToEdge converts MusclesGroup into MusclesGroupEdge.
func (mg *MusclesGroup) ToEdge(order *MusclesGroupOrder) *MusclesGroupEdge {
	if order == nil {
		order = DefaultMusclesGroupOrder
	}
	return &MusclesGroupEdge{
		Node:   mg,
		Cursor: order.Field.toCursor(mg),
	}
}

// RoutineEdge is the edge representation of Routine.
type RoutineEdge struct {
	Node   *Routine `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// RoutineConnection is the connection containing edges to Routine.
type RoutineConnection struct {
	Edges      []*RoutineEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *RoutineConnection) build(nodes []*Routine, pager *routinePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Routine
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Routine {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Routine {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoutineEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoutineEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RoutinePaginateOption enables pagination customization.
type RoutinePaginateOption func(*routinePager) error

// WithRoutineOrder configures pagination ordering.
func WithRoutineOrder(order *RoutineOrder) RoutinePaginateOption {
	if order == nil {
		order = DefaultRoutineOrder
	}
	o := *order
	return func(pager *routinePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoutineOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoutineFilter configures pagination filter.
func WithRoutineFilter(filter func(*RoutineQuery) (*RoutineQuery, error)) RoutinePaginateOption {
	return func(pager *routinePager) error {
		if filter == nil {
			return errors.New("RoutineQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routinePager struct {
	order  *RoutineOrder
	filter func(*RoutineQuery) (*RoutineQuery, error)
}

func newRoutinePager(opts []RoutinePaginateOption) (*routinePager, error) {
	pager := &routinePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoutineOrder
	}
	return pager, nil
}

func (p *routinePager) applyFilter(query *RoutineQuery) (*RoutineQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routinePager) toCursor(r *Routine) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *routinePager) applyCursors(query *RoutineQuery, after, before *Cursor) *RoutineQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRoutineOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *routinePager) applyOrder(query *RoutineQuery, reverse bool) *RoutineQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRoutineOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRoutineOrder.Field.field))
	}
	return query
}

func (p *routinePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoutineOrder.Field {
			b.Comma().Ident(DefaultRoutineOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Routine.
func (r *RoutineQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RoutinePaginateOption,
) (*RoutineConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRoutinePager(opts)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RoutineConnection{Edges: []*RoutineEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RoutineOrderField defines the ordering field of Routine.
type RoutineOrderField struct {
	field    string
	toCursor func(*Routine) Cursor
}

// RoutineOrder defines the ordering of Routine.
type RoutineOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *RoutineOrderField `json:"field"`
}

// DefaultRoutineOrder is the default ordering of Routine.
var DefaultRoutineOrder = &RoutineOrder{
	Direction: OrderDirectionAsc,
	Field: &RoutineOrderField{
		field: routine.FieldID,
		toCursor: func(r *Routine) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Routine into RoutineEdge.
func (r *Routine) ToEdge(order *RoutineOrder) *RoutineEdge {
	if order == nil {
		order = DefaultRoutineOrder
	}
	return &RoutineEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RoutineExerciseEdge is the edge representation of RoutineExercise.
type RoutineExerciseEdge struct {
	Node   *RoutineExercise `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// RoutineExerciseConnection is the connection containing edges to RoutineExercise.
type RoutineExerciseConnection struct {
	Edges      []*RoutineExerciseEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *RoutineExerciseConnection) build(nodes []*RoutineExercise, pager *routineexercisePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RoutineExercise
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RoutineExercise {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RoutineExercise {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoutineExerciseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoutineExerciseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RoutineExercisePaginateOption enables pagination customization.
type RoutineExercisePaginateOption func(*routineexercisePager) error

// WithRoutineExerciseOrder configures pagination ordering.
func WithRoutineExerciseOrder(order *RoutineExerciseOrder) RoutineExercisePaginateOption {
	if order == nil {
		order = DefaultRoutineExerciseOrder
	}
	o := *order
	return func(pager *routineexercisePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoutineExerciseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoutineExerciseFilter configures pagination filter.
func WithRoutineExerciseFilter(filter func(*RoutineExerciseQuery) (*RoutineExerciseQuery, error)) RoutineExercisePaginateOption {
	return func(pager *routineexercisePager) error {
		if filter == nil {
			return errors.New("RoutineExerciseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routineexercisePager struct {
	order  *RoutineExerciseOrder
	filter func(*RoutineExerciseQuery) (*RoutineExerciseQuery, error)
}

func newRoutineExercisePager(opts []RoutineExercisePaginateOption) (*routineexercisePager, error) {
	pager := &routineexercisePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoutineExerciseOrder
	}
	return pager, nil
}

func (p *routineexercisePager) applyFilter(query *RoutineExerciseQuery) (*RoutineExerciseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routineexercisePager) toCursor(re *RoutineExercise) Cursor {
	return p.order.Field.toCursor(re)
}

func (p *routineexercisePager) applyCursors(query *RoutineExerciseQuery, after, before *Cursor) *RoutineExerciseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRoutineExerciseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *routineexercisePager) applyOrder(query *RoutineExerciseQuery, reverse bool) *RoutineExerciseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRoutineExerciseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRoutineExerciseOrder.Field.field))
	}
	return query
}

func (p *routineexercisePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoutineExerciseOrder.Field {
			b.Comma().Ident(DefaultRoutineExerciseOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RoutineExercise.
func (re *RoutineExerciseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RoutineExercisePaginateOption,
) (*RoutineExerciseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRoutineExercisePager(opts)
	if err != nil {
		return nil, err
	}
	if re, err = pager.applyFilter(re); err != nil {
		return nil, err
	}
	conn := &RoutineExerciseConnection{Edges: []*RoutineExerciseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = re.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	re = pager.applyCursors(re, after, before)
	re = pager.applyOrder(re, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		re.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := re.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := re.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RoutineExerciseOrderField defines the ordering field of RoutineExercise.
type RoutineExerciseOrderField struct {
	field    string
	toCursor func(*RoutineExercise) Cursor
}

// RoutineExerciseOrder defines the ordering of RoutineExercise.
type RoutineExerciseOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *RoutineExerciseOrderField `json:"field"`
}

// DefaultRoutineExerciseOrder is the default ordering of RoutineExercise.
var DefaultRoutineExerciseOrder = &RoutineExerciseOrder{
	Direction: OrderDirectionAsc,
	Field: &RoutineExerciseOrderField{
		field: routineexercise.FieldID,
		toCursor: func(re *RoutineExercise) Cursor {
			return Cursor{ID: re.ID}
		},
	},
}

// ToEdge converts RoutineExercise into RoutineExerciseEdge.
func (re *RoutineExercise) ToEdge(order *RoutineExerciseOrder) *RoutineExerciseEdge {
	if order == nil {
		order = DefaultRoutineExerciseOrder
	}
	return &RoutineExerciseEdge{
		Node:   re,
		Cursor: order.Field.toCursor(re),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	order  *TokenOrder
	filter func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption) (*tokenPager, error) {
	pager := &tokenPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) *TokenQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTokenOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *tokenPager) applyOrder(query *TokenQuery, reverse bool) *TokenQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTokenOrder.Field.field))
	}
	return query
}

func (p *tokenPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	field    string
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: OrderDirectionAsc,
	Field: &TokenOrderField{
		field: token.FieldID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

func (p *userPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// WorkoutEdge is the edge representation of Workout.
type WorkoutEdge struct {
	Node   *Workout `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// WorkoutConnection is the connection containing edges to Workout.
type WorkoutConnection struct {
	Edges      []*WorkoutEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *WorkoutConnection) build(nodes []*Workout, pager *workoutPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Workout
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workout {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workout {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkoutEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkoutEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkoutPaginateOption enables pagination customization.
type WorkoutPaginateOption func(*workoutPager) error

// WithWorkoutOrder configures pagination ordering.
func WithWorkoutOrder(order *WorkoutOrder) WorkoutPaginateOption {
	if order == nil {
		order = DefaultWorkoutOrder
	}
	o := *order
	return func(pager *workoutPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkoutOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkoutFilter configures pagination filter.
func WithWorkoutFilter(filter func(*WorkoutQuery) (*WorkoutQuery, error)) WorkoutPaginateOption {
	return func(pager *workoutPager) error {
		if filter == nil {
			return errors.New("WorkoutQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workoutPager struct {
	order  *WorkoutOrder
	filter func(*WorkoutQuery) (*WorkoutQuery, error)
}

func newWorkoutPager(opts []WorkoutPaginateOption) (*workoutPager, error) {
	pager := &workoutPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkoutOrder
	}
	return pager, nil
}

func (p *workoutPager) applyFilter(query *WorkoutQuery) (*WorkoutQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workoutPager) toCursor(w *Workout) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *workoutPager) applyCursors(query *WorkoutQuery, after, before *Cursor) *WorkoutQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkoutOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workoutPager) applyOrder(query *WorkoutQuery, reverse bool) *WorkoutQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkoutOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkoutOrder.Field.field))
	}
	return query
}

func (p *workoutPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkoutOrder.Field {
			b.Comma().Ident(DefaultWorkoutOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Workout.
func (w *WorkoutQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkoutPaginateOption,
) (*WorkoutConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkoutPager(opts)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WorkoutConnection{Edges: []*WorkoutEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	w = pager.applyCursors(w, after, before)
	w = pager.applyOrder(w, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkoutOrderField defines the ordering field of Workout.
type WorkoutOrderField struct {
	field    string
	toCursor func(*Workout) Cursor
}

// WorkoutOrder defines the ordering of Workout.
type WorkoutOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *WorkoutOrderField `json:"field"`
}

// DefaultWorkoutOrder is the default ordering of Workout.
var DefaultWorkoutOrder = &WorkoutOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkoutOrderField{
		field: workout.FieldID,
		toCursor: func(w *Workout) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workout into WorkoutEdge.
func (w *Workout) ToEdge(order *WorkoutOrder) *WorkoutEdge {
	if order == nil {
		order = DefaultWorkoutOrder
	}
	return &WorkoutEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WorkoutLogEdge is the edge representation of WorkoutLog.
type WorkoutLogEdge struct {
	Node   *WorkoutLog `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// WorkoutLogConnection is the connection containing edges to WorkoutLog.
type WorkoutLogConnection struct {
	Edges      []*WorkoutLogEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *WorkoutLogConnection) build(nodes []*WorkoutLog, pager *workoutlogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WorkoutLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkoutLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkoutLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkoutLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkoutLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkoutLogPaginateOption enables pagination customization.
type WorkoutLogPaginateOption func(*workoutlogPager) error

// WithWorkoutLogOrder configures pagination ordering.
func WithWorkoutLogOrder(order *WorkoutLogOrder) WorkoutLogPaginateOption {
	if order == nil {
		order = DefaultWorkoutLogOrder
	}
	o := *order
	return func(pager *workoutlogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkoutLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkoutLogFilter configures pagination filter.
func WithWorkoutLogFilter(filter func(*WorkoutLogQuery) (*WorkoutLogQuery, error)) WorkoutLogPaginateOption {
	return func(pager *workoutlogPager) error {
		if filter == nil {
			return errors.New("WorkoutLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workoutlogPager struct {
	order  *WorkoutLogOrder
	filter func(*WorkoutLogQuery) (*WorkoutLogQuery, error)
}

func newWorkoutLogPager(opts []WorkoutLogPaginateOption) (*workoutlogPager, error) {
	pager := &workoutlogPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkoutLogOrder
	}
	return pager, nil
}

func (p *workoutlogPager) applyFilter(query *WorkoutLogQuery) (*WorkoutLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workoutlogPager) toCursor(wl *WorkoutLog) Cursor {
	return p.order.Field.toCursor(wl)
}

func (p *workoutlogPager) applyCursors(query *WorkoutLogQuery, after, before *Cursor) *WorkoutLogQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkoutLogOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workoutlogPager) applyOrder(query *WorkoutLogQuery, reverse bool) *WorkoutLogQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkoutLogOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkoutLogOrder.Field.field))
	}
	return query
}

func (p *workoutlogPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkoutLogOrder.Field {
			b.Comma().Ident(DefaultWorkoutLogOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkoutLog.
func (wl *WorkoutLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkoutLogPaginateOption,
) (*WorkoutLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkoutLogPager(opts)
	if err != nil {
		return nil, err
	}
	if wl, err = pager.applyFilter(wl); err != nil {
		return nil, err
	}
	conn := &WorkoutLogConnection{Edges: []*WorkoutLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wl.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	wl = pager.applyCursors(wl, after, before)
	wl = pager.applyOrder(wl, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		wl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wl.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := wl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkoutLogOrderField defines the ordering field of WorkoutLog.
type WorkoutLogOrderField struct {
	field    string
	toCursor func(*WorkoutLog) Cursor
}

// WorkoutLogOrder defines the ordering of WorkoutLog.
type WorkoutLogOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *WorkoutLogOrderField `json:"field"`
}

// DefaultWorkoutLogOrder is the default ordering of WorkoutLog.
var DefaultWorkoutLogOrder = &WorkoutLogOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkoutLogOrderField{
		field: workoutlog.FieldID,
		toCursor: func(wl *WorkoutLog) Cursor {
			return Cursor{ID: wl.ID}
		},
	},
}

// ToEdge converts WorkoutLog into WorkoutLogEdge.
func (wl *WorkoutLog) ToEdge(order *WorkoutLogOrder) *WorkoutLogEdge {
	if order == nil {
		order = DefaultWorkoutLogOrder
	}
	return &WorkoutLogEdge{
		Node:   wl,
		Cursor: order.Field.toCursor(wl),
	}
}
