// Code generated by ent, DO NOT EDIT.

package ent

import (
	"github.com/sahidrahman404/gigachad-api/ent/equipment"
	"github.com/sahidrahman404/gigachad-api/ent/exercise"
	"github.com/sahidrahman404/gigachad-api/ent/exercisetype"
	"github.com/sahidrahman404/gigachad-api/ent/musclesgroup"
	"github.com/sahidrahman404/gigachad-api/ent/predicate"
	"github.com/sahidrahman404/gigachad-api/ent/routine"
	"github.com/sahidrahman404/gigachad-api/ent/routineexercise"
	"github.com/sahidrahman404/gigachad-api/ent/token"
	"github.com/sahidrahman404/gigachad-api/ent/user"
	"github.com/sahidrahman404/gigachad-api/ent/workout"
	"github.com/sahidrahman404/gigachad-api/ent/workoutlog"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 10)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   equipment.Table,
			Columns: equipment.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: equipment.FieldID,
			},
		},
		Type: "Equipment",
		Fields: map[string]*sqlgraph.FieldSpec{
			equipment.FieldName:  {Type: field.TypeString, Column: equipment.FieldName},
			equipment.FieldImage: {Type: field.TypeJSON, Column: equipment.FieldImage},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   exercise.Table,
			Columns: exercise.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: exercise.FieldID,
			},
		},
		Type: "Exercise",
		Fields: map[string]*sqlgraph.FieldSpec{
			exercise.FieldName:   {Type: field.TypeString, Column: exercise.FieldName},
			exercise.FieldImage:  {Type: field.TypeJSON, Column: exercise.FieldImage},
			exercise.FieldHowTo:  {Type: field.TypeString, Column: exercise.FieldHowTo},
			exercise.FieldUserID: {Type: field.TypeString, Column: exercise.FieldUserID},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   exercisetype.Table,
			Columns: exercisetype.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: exercisetype.FieldID,
			},
		},
		Type: "ExerciseType",
		Fields: map[string]*sqlgraph.FieldSpec{
			exercisetype.FieldName:        {Type: field.TypeString, Column: exercisetype.FieldName},
			exercisetype.FieldProperties:  {Type: field.TypeJSON, Column: exercisetype.FieldProperties},
			exercisetype.FieldDescription: {Type: field.TypeString, Column: exercisetype.FieldDescription},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   musclesgroup.Table,
			Columns: musclesgroup.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: musclesgroup.FieldID,
			},
		},
		Type: "MusclesGroup",
		Fields: map[string]*sqlgraph.FieldSpec{
			musclesgroup.FieldName:  {Type: field.TypeString, Column: musclesgroup.FieldName},
			musclesgroup.FieldImage: {Type: field.TypeJSON, Column: musclesgroup.FieldImage},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   routine.Table,
			Columns: routine.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: routine.FieldID,
			},
		},
		Type: "Routine",
		Fields: map[string]*sqlgraph.FieldSpec{
			routine.FieldName:       {Type: field.TypeString, Column: routine.FieldName},
			routine.FieldReminderID: {Type: field.TypeString, Column: routine.FieldReminderID},
			routine.FieldReminders:  {Type: field.TypeJSON, Column: routine.FieldReminders},
			routine.FieldUserID:     {Type: field.TypeString, Column: routine.FieldUserID},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   routineexercise.Table,
			Columns: routineexercise.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: routineexercise.FieldID,
			},
		},
		Type: "RoutineExercise",
		Fields: map[string]*sqlgraph.FieldSpec{
			routineexercise.FieldRestTime:   {Type: field.TypeString, Column: routineexercise.FieldRestTime},
			routineexercise.FieldSets:       {Type: field.TypeJSON, Column: routineexercise.FieldSets},
			routineexercise.FieldRoutineID:  {Type: field.TypeString, Column: routineexercise.FieldRoutineID},
			routineexercise.FieldExerciseID: {Type: field.TypeString, Column: routineexercise.FieldExerciseID},
			routineexercise.FieldUserID:     {Type: field.TypeString, Column: routineexercise.FieldUserID},
			routineexercise.FieldOrder:      {Type: field.TypeInt, Column: routineexercise.FieldOrder},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   token.Table,
			Columns: token.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: token.FieldID,
			},
		},
		Type: "Token",
		Fields: map[string]*sqlgraph.FieldSpec{
			token.FieldHash:   {Type: field.TypeBytes, Column: token.FieldHash},
			token.FieldExpiry: {Type: field.TypeString, Column: token.FieldExpiry},
			token.FieldScope:  {Type: field.TypeString, Column: token.FieldScope},
			token.FieldUserID: {Type: field.TypeString, Column: token.FieldUserID},
		},
	}
	graph.Nodes[7] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldEmail:          {Type: field.TypeString, Column: user.FieldEmail},
			user.FieldUsername:       {Type: field.TypeString, Column: user.FieldUsername},
			user.FieldHashedPassword: {Type: field.TypeString, Column: user.FieldHashedPassword},
			user.FieldName:           {Type: field.TypeString, Column: user.FieldName},
			user.FieldUserPreference: {Type: field.TypeEnum, Column: user.FieldUserPreference},
			user.FieldCreatedAt:      {Type: field.TypeTime, Column: user.FieldCreatedAt},
			user.FieldActivated:      {Type: field.TypeInt, Column: user.FieldActivated},
			user.FieldVersion:        {Type: field.TypeInt, Column: user.FieldVersion},
		},
	}
	graph.Nodes[8] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   workout.Table,
			Columns: workout.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: workout.FieldID,
			},
		},
		Type: "Workout",
		Fields: map[string]*sqlgraph.FieldSpec{
			workout.FieldVolume:      {Type: field.TypeInt, Column: workout.FieldVolume},
			workout.FieldDuration:    {Type: field.TypeString, Column: workout.FieldDuration},
			workout.FieldSets:        {Type: field.TypeInt, Column: workout.FieldSets},
			workout.FieldCreatedAt:   {Type: field.TypeTime, Column: workout.FieldCreatedAt},
			workout.FieldImage:       {Type: field.TypeJSON, Column: workout.FieldImage},
			workout.FieldDescription: {Type: field.TypeString, Column: workout.FieldDescription},
			workout.FieldUserID:      {Type: field.TypeString, Column: workout.FieldUserID},
		},
	}
	graph.Nodes[9] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   workoutlog.Table,
			Columns: workoutlog.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: workoutlog.FieldID,
			},
		},
		Type: "WorkoutLog",
		Fields: map[string]*sqlgraph.FieldSpec{
			workoutlog.FieldSets:       {Type: field.TypeJSON, Column: workoutlog.FieldSets},
			workoutlog.FieldCreatedAt:  {Type: field.TypeTime, Column: workoutlog.FieldCreatedAt},
			workoutlog.FieldWorkoutID:  {Type: field.TypeString, Column: workoutlog.FieldWorkoutID},
			workoutlog.FieldExerciseID: {Type: field.TypeString, Column: workoutlog.FieldExerciseID},
			workoutlog.FieldUserID:     {Type: field.TypeString, Column: workoutlog.FieldUserID},
		},
	}
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   equipment.ExercisesTable,
			Columns: equipment.ExercisesPrimaryKey,
			Bidi:    false,
		},
		"Equipment",
		"Exercise",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   exercise.UsersTable,
			Columns: []string{exercise.UsersColumn},
			Bidi:    false,
		},
		"Exercise",
		"User",
	)
	graph.MustAddE(
		"equipment",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   exercise.EquipmentTable,
			Columns: exercise.EquipmentPrimaryKey,
			Bidi:    false,
		},
		"Exercise",
		"Equipment",
	)
	graph.MustAddE(
		"muscles_groups",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   exercise.MusclesGroupsTable,
			Columns: exercise.MusclesGroupsPrimaryKey,
			Bidi:    false,
		},
		"Exercise",
		"MusclesGroup",
	)
	graph.MustAddE(
		"exercise_types",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   exercise.ExerciseTypesTable,
			Columns: exercise.ExerciseTypesPrimaryKey,
			Bidi:    false,
		},
		"Exercise",
		"ExerciseType",
	)
	graph.MustAddE(
		"routines",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   exercise.RoutinesTable,
			Columns: exercise.RoutinesPrimaryKey,
			Bidi:    false,
		},
		"Exercise",
		"Routine",
	)
	graph.MustAddE(
		"workouts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   exercise.WorkoutsTable,
			Columns: exercise.WorkoutsPrimaryKey,
			Bidi:    false,
		},
		"Exercise",
		"Workout",
	)
	graph.MustAddE(
		"routine_exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   exercise.RoutineExercisesTable,
			Columns: []string{exercise.RoutineExercisesColumn},
			Bidi:    false,
		},
		"Exercise",
		"RoutineExercise",
	)
	graph.MustAddE(
		"workout_logs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   exercise.WorkoutLogsTable,
			Columns: []string{exercise.WorkoutLogsColumn},
			Bidi:    false,
		},
		"Exercise",
		"WorkoutLog",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   exercisetype.ExercisesTable,
			Columns: exercisetype.ExercisesPrimaryKey,
			Bidi:    false,
		},
		"ExerciseType",
		"Exercise",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   musclesgroup.ExercisesTable,
			Columns: musclesgroup.ExercisesPrimaryKey,
			Bidi:    false,
		},
		"MusclesGroup",
		"Exercise",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   routine.ExercisesTable,
			Columns: routine.ExercisesPrimaryKey,
			Bidi:    false,
		},
		"Routine",
		"Exercise",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   routine.UsersTable,
			Columns: []string{routine.UsersColumn},
			Bidi:    false,
		},
		"Routine",
		"User",
	)
	graph.MustAddE(
		"routine_exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   routine.RoutineExercisesTable,
			Columns: []string{routine.RoutineExercisesColumn},
			Bidi:    false,
		},
		"Routine",
		"RoutineExercise",
	)
	graph.MustAddE(
		"routines",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   routineexercise.RoutinesTable,
			Columns: []string{routineexercise.RoutinesColumn},
			Bidi:    false,
		},
		"RoutineExercise",
		"Routine",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   routineexercise.ExercisesTable,
			Columns: []string{routineexercise.ExercisesColumn},
			Bidi:    false,
		},
		"RoutineExercise",
		"Exercise",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   routineexercise.UsersTable,
			Columns: []string{routineexercise.UsersColumn},
			Bidi:    false,
		},
		"RoutineExercise",
		"User",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   token.UsersTable,
			Columns: []string{token.UsersColumn},
			Bidi:    false,
		},
		"Token",
		"User",
	)
	graph.MustAddE(
		"tokens",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokensTable,
			Columns: []string{user.TokensColumn},
			Bidi:    false,
		},
		"User",
		"Token",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ExercisesTable,
			Columns: []string{user.ExercisesColumn},
			Bidi:    false,
		},
		"User",
		"Exercise",
	)
	graph.MustAddE(
		"routines",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.RoutinesTable,
			Columns: []string{user.RoutinesColumn},
			Bidi:    false,
		},
		"User",
		"Routine",
	)
	graph.MustAddE(
		"workouts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.WorkoutsTable,
			Columns: []string{user.WorkoutsColumn},
			Bidi:    false,
		},
		"User",
		"Workout",
	)
	graph.MustAddE(
		"workout_logs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.WorkoutLogsTable,
			Columns: []string{user.WorkoutLogsColumn},
			Bidi:    false,
		},
		"User",
		"WorkoutLog",
	)
	graph.MustAddE(
		"routine_exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.RoutineExercisesTable,
			Columns: []string{user.RoutineExercisesColumn},
			Bidi:    false,
		},
		"User",
		"RoutineExercise",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workout.UsersTable,
			Columns: []string{workout.UsersColumn},
			Bidi:    false,
		},
		"Workout",
		"User",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   workout.ExercisesTable,
			Columns: workout.ExercisesPrimaryKey,
			Bidi:    false,
		},
		"Workout",
		"Exercise",
	)
	graph.MustAddE(
		"workout_logs",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   workout.WorkoutLogsTable,
			Columns: []string{workout.WorkoutLogsColumn},
			Bidi:    false,
		},
		"Workout",
		"WorkoutLog",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workoutlog.UsersTable,
			Columns: []string{workoutlog.UsersColumn},
			Bidi:    false,
		},
		"WorkoutLog",
		"User",
	)
	graph.MustAddE(
		"workouts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   workoutlog.WorkoutsTable,
			Columns: []string{workoutlog.WorkoutsColumn},
			Bidi:    false,
		},
		"WorkoutLog",
		"Workout",
	)
	graph.MustAddE(
		"exercises",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   workoutlog.ExercisesTable,
			Columns: []string{workoutlog.ExercisesColumn},
			Bidi:    false,
		},
		"WorkoutLog",
		"Exercise",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (eq *EquipmentQuery) addPredicate(pred func(s *sql.Selector)) {
	eq.predicates = append(eq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the EquipmentQuery builder.
func (eq *EquipmentQuery) Filter() *EquipmentFilter {
	return &EquipmentFilter{config: eq.config, predicateAdder: eq}
}

// addPredicate implements the predicateAdder interface.
func (m *EquipmentMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the EquipmentMutation builder.
func (m *EquipmentMutation) Filter() *EquipmentFilter {
	return &EquipmentFilter{config: m.config, predicateAdder: m}
}

// EquipmentFilter provides a generic filtering capability at runtime for EquipmentQuery.
type EquipmentFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *EquipmentFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *EquipmentFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(equipment.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *EquipmentFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(equipment.FieldName))
}

// WhereImage applies the entql json.RawMessage predicate on the image field.
func (f *EquipmentFilter) WhereImage(p entql.BytesP) {
	f.Where(p.Field(equipment.FieldImage))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *EquipmentFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *EquipmentFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (eq *ExerciseQuery) addPredicate(pred func(s *sql.Selector)) {
	eq.predicates = append(eq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ExerciseQuery builder.
func (eq *ExerciseQuery) Filter() *ExerciseFilter {
	return &ExerciseFilter{config: eq.config, predicateAdder: eq}
}

// addPredicate implements the predicateAdder interface.
func (m *ExerciseMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ExerciseMutation builder.
func (m *ExerciseMutation) Filter() *ExerciseFilter {
	return &ExerciseFilter{config: m.config, predicateAdder: m}
}

// ExerciseFilter provides a generic filtering capability at runtime for ExerciseQuery.
type ExerciseFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ExerciseFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ExerciseFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(exercise.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *ExerciseFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(exercise.FieldName))
}

// WhereImage applies the entql json.RawMessage predicate on the image field.
func (f *ExerciseFilter) WhereImage(p entql.BytesP) {
	f.Where(p.Field(exercise.FieldImage))
}

// WhereHowTo applies the entql string predicate on the how_to field.
func (f *ExerciseFilter) WhereHowTo(p entql.StringP) {
	f.Where(p.Field(exercise.FieldHowTo))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *ExerciseFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(exercise.FieldUserID))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *ExerciseFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasEquipment applies a predicate to check if query has an edge equipment.
func (f *ExerciseFilter) WhereHasEquipment() {
	f.Where(entql.HasEdge("equipment"))
}

// WhereHasEquipmentWith applies a predicate to check if query has an edge equipment with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasEquipmentWith(preds ...predicate.Equipment) {
	f.Where(entql.HasEdgeWith("equipment", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasMusclesGroups applies a predicate to check if query has an edge muscles_groups.
func (f *ExerciseFilter) WhereHasMusclesGroups() {
	f.Where(entql.HasEdge("muscles_groups"))
}

// WhereHasMusclesGroupsWith applies a predicate to check if query has an edge muscles_groups with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasMusclesGroupsWith(preds ...predicate.MusclesGroup) {
	f.Where(entql.HasEdgeWith("muscles_groups", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasExerciseTypes applies a predicate to check if query has an edge exercise_types.
func (f *ExerciseFilter) WhereHasExerciseTypes() {
	f.Where(entql.HasEdge("exercise_types"))
}

// WhereHasExerciseTypesWith applies a predicate to check if query has an edge exercise_types with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasExerciseTypesWith(preds ...predicate.ExerciseType) {
	f.Where(entql.HasEdgeWith("exercise_types", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRoutines applies a predicate to check if query has an edge routines.
func (f *ExerciseFilter) WhereHasRoutines() {
	f.Where(entql.HasEdge("routines"))
}

// WhereHasRoutinesWith applies a predicate to check if query has an edge routines with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasRoutinesWith(preds ...predicate.Routine) {
	f.Where(entql.HasEdgeWith("routines", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkouts applies a predicate to check if query has an edge workouts.
func (f *ExerciseFilter) WhereHasWorkouts() {
	f.Where(entql.HasEdge("workouts"))
}

// WhereHasWorkoutsWith applies a predicate to check if query has an edge workouts with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasWorkoutsWith(preds ...predicate.Workout) {
	f.Where(entql.HasEdgeWith("workouts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRoutineExercises applies a predicate to check if query has an edge routine_exercises.
func (f *ExerciseFilter) WhereHasRoutineExercises() {
	f.Where(entql.HasEdge("routine_exercises"))
}

// WhereHasRoutineExercisesWith applies a predicate to check if query has an edge routine_exercises with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasRoutineExercisesWith(preds ...predicate.RoutineExercise) {
	f.Where(entql.HasEdgeWith("routine_exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkoutLogs applies a predicate to check if query has an edge workout_logs.
func (f *ExerciseFilter) WhereHasWorkoutLogs() {
	f.Where(entql.HasEdge("workout_logs"))
}

// WhereHasWorkoutLogsWith applies a predicate to check if query has an edge workout_logs with a given conditions (other predicates).
func (f *ExerciseFilter) WhereHasWorkoutLogsWith(preds ...predicate.WorkoutLog) {
	f.Where(entql.HasEdgeWith("workout_logs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (etq *ExerciseTypeQuery) addPredicate(pred func(s *sql.Selector)) {
	etq.predicates = append(etq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ExerciseTypeQuery builder.
func (etq *ExerciseTypeQuery) Filter() *ExerciseTypeFilter {
	return &ExerciseTypeFilter{config: etq.config, predicateAdder: etq}
}

// addPredicate implements the predicateAdder interface.
func (m *ExerciseTypeMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ExerciseTypeMutation builder.
func (m *ExerciseTypeMutation) Filter() *ExerciseTypeFilter {
	return &ExerciseTypeFilter{config: m.config, predicateAdder: m}
}

// ExerciseTypeFilter provides a generic filtering capability at runtime for ExerciseTypeQuery.
type ExerciseTypeFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ExerciseTypeFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ExerciseTypeFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(exercisetype.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *ExerciseTypeFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(exercisetype.FieldName))
}

// WhereProperties applies the entql json.RawMessage predicate on the properties field.
func (f *ExerciseTypeFilter) WhereProperties(p entql.BytesP) {
	f.Where(p.Field(exercisetype.FieldProperties))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *ExerciseTypeFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(exercisetype.FieldDescription))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *ExerciseTypeFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *ExerciseTypeFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (mgq *MusclesGroupQuery) addPredicate(pred func(s *sql.Selector)) {
	mgq.predicates = append(mgq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the MusclesGroupQuery builder.
func (mgq *MusclesGroupQuery) Filter() *MusclesGroupFilter {
	return &MusclesGroupFilter{config: mgq.config, predicateAdder: mgq}
}

// addPredicate implements the predicateAdder interface.
func (m *MusclesGroupMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the MusclesGroupMutation builder.
func (m *MusclesGroupMutation) Filter() *MusclesGroupFilter {
	return &MusclesGroupFilter{config: m.config, predicateAdder: m}
}

// MusclesGroupFilter provides a generic filtering capability at runtime for MusclesGroupQuery.
type MusclesGroupFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *MusclesGroupFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *MusclesGroupFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(musclesgroup.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *MusclesGroupFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(musclesgroup.FieldName))
}

// WhereImage applies the entql json.RawMessage predicate on the image field.
func (f *MusclesGroupFilter) WhereImage(p entql.BytesP) {
	f.Where(p.Field(musclesgroup.FieldImage))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *MusclesGroupFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *MusclesGroupFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (rq *RoutineQuery) addPredicate(pred func(s *sql.Selector)) {
	rq.predicates = append(rq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the RoutineQuery builder.
func (rq *RoutineQuery) Filter() *RoutineFilter {
	return &RoutineFilter{config: rq.config, predicateAdder: rq}
}

// addPredicate implements the predicateAdder interface.
func (m *RoutineMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the RoutineMutation builder.
func (m *RoutineMutation) Filter() *RoutineFilter {
	return &RoutineFilter{config: m.config, predicateAdder: m}
}

// RoutineFilter provides a generic filtering capability at runtime for RoutineQuery.
type RoutineFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *RoutineFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *RoutineFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(routine.FieldID))
}

// WhereName applies the entql string predicate on the name field.
func (f *RoutineFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(routine.FieldName))
}

// WhereReminderID applies the entql string predicate on the reminder_id field.
func (f *RoutineFilter) WhereReminderID(p entql.StringP) {
	f.Where(p.Field(routine.FieldReminderID))
}

// WhereReminders applies the entql json.RawMessage predicate on the reminders field.
func (f *RoutineFilter) WhereReminders(p entql.BytesP) {
	f.Where(p.Field(routine.FieldReminders))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *RoutineFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(routine.FieldUserID))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *RoutineFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *RoutineFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *RoutineFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *RoutineFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRoutineExercises applies a predicate to check if query has an edge routine_exercises.
func (f *RoutineFilter) WhereHasRoutineExercises() {
	f.Where(entql.HasEdge("routine_exercises"))
}

// WhereHasRoutineExercisesWith applies a predicate to check if query has an edge routine_exercises with a given conditions (other predicates).
func (f *RoutineFilter) WhereHasRoutineExercisesWith(preds ...predicate.RoutineExercise) {
	f.Where(entql.HasEdgeWith("routine_exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (req *RoutineExerciseQuery) addPredicate(pred func(s *sql.Selector)) {
	req.predicates = append(req.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the RoutineExerciseQuery builder.
func (req *RoutineExerciseQuery) Filter() *RoutineExerciseFilter {
	return &RoutineExerciseFilter{config: req.config, predicateAdder: req}
}

// addPredicate implements the predicateAdder interface.
func (m *RoutineExerciseMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the RoutineExerciseMutation builder.
func (m *RoutineExerciseMutation) Filter() *RoutineExerciseFilter {
	return &RoutineExerciseFilter{config: m.config, predicateAdder: m}
}

// RoutineExerciseFilter provides a generic filtering capability at runtime for RoutineExerciseQuery.
type RoutineExerciseFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *RoutineExerciseFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *RoutineExerciseFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(routineexercise.FieldID))
}

// WhereRestTime applies the entql string predicate on the rest_time field.
func (f *RoutineExerciseFilter) WhereRestTime(p entql.StringP) {
	f.Where(p.Field(routineexercise.FieldRestTime))
}

// WhereSets applies the entql json.RawMessage predicate on the sets field.
func (f *RoutineExerciseFilter) WhereSets(p entql.BytesP) {
	f.Where(p.Field(routineexercise.FieldSets))
}

// WhereRoutineID applies the entql string predicate on the routine_id field.
func (f *RoutineExerciseFilter) WhereRoutineID(p entql.StringP) {
	f.Where(p.Field(routineexercise.FieldRoutineID))
}

// WhereExerciseID applies the entql string predicate on the exercise_id field.
func (f *RoutineExerciseFilter) WhereExerciseID(p entql.StringP) {
	f.Where(p.Field(routineexercise.FieldExerciseID))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *RoutineExerciseFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(routineexercise.FieldUserID))
}

// WhereOrder applies the entql int predicate on the order field.
func (f *RoutineExerciseFilter) WhereOrder(p entql.IntP) {
	f.Where(p.Field(routineexercise.FieldOrder))
}

// WhereHasRoutines applies a predicate to check if query has an edge routines.
func (f *RoutineExerciseFilter) WhereHasRoutines() {
	f.Where(entql.HasEdge("routines"))
}

// WhereHasRoutinesWith applies a predicate to check if query has an edge routines with a given conditions (other predicates).
func (f *RoutineExerciseFilter) WhereHasRoutinesWith(preds ...predicate.Routine) {
	f.Where(entql.HasEdgeWith("routines", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *RoutineExerciseFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *RoutineExerciseFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *RoutineExerciseFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *RoutineExerciseFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (tq *TokenQuery) addPredicate(pred func(s *sql.Selector)) {
	tq.predicates = append(tq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TokenQuery builder.
func (tq *TokenQuery) Filter() *TokenFilter {
	return &TokenFilter{config: tq.config, predicateAdder: tq}
}

// addPredicate implements the predicateAdder interface.
func (m *TokenMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TokenMutation builder.
func (m *TokenMutation) Filter() *TokenFilter {
	return &TokenFilter{config: m.config, predicateAdder: m}
}

// TokenFilter provides a generic filtering capability at runtime for TokenQuery.
type TokenFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TokenFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *TokenFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(token.FieldID))
}

// WhereHash applies the entql []byte predicate on the hash field.
func (f *TokenFilter) WhereHash(p entql.BytesP) {
	f.Where(p.Field(token.FieldHash))
}

// WhereExpiry applies the entql string predicate on the expiry field.
func (f *TokenFilter) WhereExpiry(p entql.StringP) {
	f.Where(p.Field(token.FieldExpiry))
}

// WhereScope applies the entql string predicate on the scope field.
func (f *TokenFilter) WhereScope(p entql.StringP) {
	f.Where(p.Field(token.FieldScope))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *TokenFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(token.FieldUserID))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *TokenFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *TokenFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[7].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(user.FieldID))
}

// WhereEmail applies the entql string predicate on the email field.
func (f *UserFilter) WhereEmail(p entql.StringP) {
	f.Where(p.Field(user.FieldEmail))
}

// WhereUsername applies the entql string predicate on the username field.
func (f *UserFilter) WhereUsername(p entql.StringP) {
	f.Where(p.Field(user.FieldUsername))
}

// WhereHashedPassword applies the entql string predicate on the hashed_password field.
func (f *UserFilter) WhereHashedPassword(p entql.StringP) {
	f.Where(p.Field(user.FieldHashedPassword))
}

// WhereName applies the entql string predicate on the name field.
func (f *UserFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(user.FieldName))
}

// WhereUserPreference applies the entql string predicate on the user_preference field.
func (f *UserFilter) WhereUserPreference(p entql.StringP) {
	f.Where(p.Field(user.FieldUserPreference))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *UserFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreatedAt))
}

// WhereActivated applies the entql int predicate on the activated field.
func (f *UserFilter) WhereActivated(p entql.IntP) {
	f.Where(p.Field(user.FieldActivated))
}

// WhereVersion applies the entql int predicate on the version field.
func (f *UserFilter) WhereVersion(p entql.IntP) {
	f.Where(p.Field(user.FieldVersion))
}

// WhereHasTokens applies a predicate to check if query has an edge tokens.
func (f *UserFilter) WhereHasTokens() {
	f.Where(entql.HasEdge("tokens"))
}

// WhereHasTokensWith applies a predicate to check if query has an edge tokens with a given conditions (other predicates).
func (f *UserFilter) WhereHasTokensWith(preds ...predicate.Token) {
	f.Where(entql.HasEdgeWith("tokens", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *UserFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *UserFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRoutines applies a predicate to check if query has an edge routines.
func (f *UserFilter) WhereHasRoutines() {
	f.Where(entql.HasEdge("routines"))
}

// WhereHasRoutinesWith applies a predicate to check if query has an edge routines with a given conditions (other predicates).
func (f *UserFilter) WhereHasRoutinesWith(preds ...predicate.Routine) {
	f.Where(entql.HasEdgeWith("routines", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkouts applies a predicate to check if query has an edge workouts.
func (f *UserFilter) WhereHasWorkouts() {
	f.Where(entql.HasEdge("workouts"))
}

// WhereHasWorkoutsWith applies a predicate to check if query has an edge workouts with a given conditions (other predicates).
func (f *UserFilter) WhereHasWorkoutsWith(preds ...predicate.Workout) {
	f.Where(entql.HasEdgeWith("workouts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkoutLogs applies a predicate to check if query has an edge workout_logs.
func (f *UserFilter) WhereHasWorkoutLogs() {
	f.Where(entql.HasEdge("workout_logs"))
}

// WhereHasWorkoutLogsWith applies a predicate to check if query has an edge workout_logs with a given conditions (other predicates).
func (f *UserFilter) WhereHasWorkoutLogsWith(preds ...predicate.WorkoutLog) {
	f.Where(entql.HasEdgeWith("workout_logs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRoutineExercises applies a predicate to check if query has an edge routine_exercises.
func (f *UserFilter) WhereHasRoutineExercises() {
	f.Where(entql.HasEdge("routine_exercises"))
}

// WhereHasRoutineExercisesWith applies a predicate to check if query has an edge routine_exercises with a given conditions (other predicates).
func (f *UserFilter) WhereHasRoutineExercisesWith(preds ...predicate.RoutineExercise) {
	f.Where(entql.HasEdgeWith("routine_exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (wq *WorkoutQuery) addPredicate(pred func(s *sql.Selector)) {
	wq.predicates = append(wq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the WorkoutQuery builder.
func (wq *WorkoutQuery) Filter() *WorkoutFilter {
	return &WorkoutFilter{config: wq.config, predicateAdder: wq}
}

// addPredicate implements the predicateAdder interface.
func (m *WorkoutMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the WorkoutMutation builder.
func (m *WorkoutMutation) Filter() *WorkoutFilter {
	return &WorkoutFilter{config: m.config, predicateAdder: m}
}

// WorkoutFilter provides a generic filtering capability at runtime for WorkoutQuery.
type WorkoutFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *WorkoutFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[8].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *WorkoutFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(workout.FieldID))
}

// WhereVolume applies the entql int predicate on the volume field.
func (f *WorkoutFilter) WhereVolume(p entql.IntP) {
	f.Where(p.Field(workout.FieldVolume))
}

// WhereDuration applies the entql string predicate on the duration field.
func (f *WorkoutFilter) WhereDuration(p entql.StringP) {
	f.Where(p.Field(workout.FieldDuration))
}

// WhereSets applies the entql int predicate on the sets field.
func (f *WorkoutFilter) WhereSets(p entql.IntP) {
	f.Where(p.Field(workout.FieldSets))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *WorkoutFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(workout.FieldCreatedAt))
}

// WhereImage applies the entql json.RawMessage predicate on the image field.
func (f *WorkoutFilter) WhereImage(p entql.BytesP) {
	f.Where(p.Field(workout.FieldImage))
}

// WhereDescription applies the entql string predicate on the description field.
func (f *WorkoutFilter) WhereDescription(p entql.StringP) {
	f.Where(p.Field(workout.FieldDescription))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *WorkoutFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(workout.FieldUserID))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *WorkoutFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *WorkoutFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *WorkoutFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *WorkoutFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkoutLogs applies a predicate to check if query has an edge workout_logs.
func (f *WorkoutFilter) WhereHasWorkoutLogs() {
	f.Where(entql.HasEdge("workout_logs"))
}

// WhereHasWorkoutLogsWith applies a predicate to check if query has an edge workout_logs with a given conditions (other predicates).
func (f *WorkoutFilter) WhereHasWorkoutLogsWith(preds ...predicate.WorkoutLog) {
	f.Where(entql.HasEdgeWith("workout_logs", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (wlq *WorkoutLogQuery) addPredicate(pred func(s *sql.Selector)) {
	wlq.predicates = append(wlq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the WorkoutLogQuery builder.
func (wlq *WorkoutLogQuery) Filter() *WorkoutLogFilter {
	return &WorkoutLogFilter{config: wlq.config, predicateAdder: wlq}
}

// addPredicate implements the predicateAdder interface.
func (m *WorkoutLogMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the WorkoutLogMutation builder.
func (m *WorkoutLogMutation) Filter() *WorkoutLogFilter {
	return &WorkoutLogFilter{config: m.config, predicateAdder: m}
}

// WorkoutLogFilter provides a generic filtering capability at runtime for WorkoutLogQuery.
type WorkoutLogFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *WorkoutLogFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[9].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *WorkoutLogFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(workoutlog.FieldID))
}

// WhereSets applies the entql json.RawMessage predicate on the sets field.
func (f *WorkoutLogFilter) WhereSets(p entql.BytesP) {
	f.Where(p.Field(workoutlog.FieldSets))
}

// WhereCreatedAt applies the entql time.Time predicate on the created_at field.
func (f *WorkoutLogFilter) WhereCreatedAt(p entql.TimeP) {
	f.Where(p.Field(workoutlog.FieldCreatedAt))
}

// WhereWorkoutID applies the entql string predicate on the workout_id field.
func (f *WorkoutLogFilter) WhereWorkoutID(p entql.StringP) {
	f.Where(p.Field(workoutlog.FieldWorkoutID))
}

// WhereExerciseID applies the entql string predicate on the exercise_id field.
func (f *WorkoutLogFilter) WhereExerciseID(p entql.StringP) {
	f.Where(p.Field(workoutlog.FieldExerciseID))
}

// WhereUserID applies the entql string predicate on the user_id field.
func (f *WorkoutLogFilter) WhereUserID(p entql.StringP) {
	f.Where(p.Field(workoutlog.FieldUserID))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *WorkoutLogFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *WorkoutLogFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasWorkouts applies a predicate to check if query has an edge workouts.
func (f *WorkoutLogFilter) WhereHasWorkouts() {
	f.Where(entql.HasEdge("workouts"))
}

// WhereHasWorkoutsWith applies a predicate to check if query has an edge workouts with a given conditions (other predicates).
func (f *WorkoutLogFilter) WhereHasWorkoutsWith(preds ...predicate.Workout) {
	f.Where(entql.HasEdgeWith("workouts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasExercises applies a predicate to check if query has an edge exercises.
func (f *WorkoutLogFilter) WhereHasExercises() {
	f.Where(entql.HasEdge("exercises"))
}

// WhereHasExercisesWith applies a predicate to check if query has an edge exercises with a given conditions (other predicates).
func (f *WorkoutLogFilter) WhereHasExercisesWith(preds ...predicate.Exercise) {
	f.Where(entql.HasEdgeWith("exercises", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
