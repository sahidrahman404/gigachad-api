// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/sahidrahman404/gigachad-api/ent/equipment"
	"github.com/sahidrahman404/gigachad-api/ent/exercise"
	"github.com/sahidrahman404/gigachad-api/ent/exercisetype"
	"github.com/sahidrahman404/gigachad-api/ent/musclesgroup"
	"github.com/sahidrahman404/gigachad-api/ent/predicate"
	"github.com/sahidrahman404/gigachad-api/ent/routine"
	"github.com/sahidrahman404/gigachad-api/ent/routineexercise"
	"github.com/sahidrahman404/gigachad-api/ent/token"
	"github.com/sahidrahman404/gigachad-api/ent/user"
	"github.com/sahidrahman404/gigachad-api/ent/workout"
	"github.com/sahidrahman404/gigachad-api/ent/workoutlog"
)

// EquipmentWhereInput represents a where input for filtering Equipment queries.
type EquipmentWhereInput struct {
	Predicates []predicate.Equipment  `json:"-"`
	Not        *EquipmentWhereInput   `json:"not,omitempty"`
	Or         []*EquipmentWhereInput `json:"or,omitempty"`
	And        []*EquipmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EquipmentWhereInput) AddPredicates(predicates ...predicate.Equipment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EquipmentWhereInput filter on the EquipmentQuery builder.
func (i *EquipmentWhereInput) Filter(q *EquipmentQuery) (*EquipmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEquipmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEquipmentWhereInput is returned in case the EquipmentWhereInput is empty.
var ErrEmptyEquipmentWhereInput = errors.New("ent: empty predicate EquipmentWhereInput")

// P returns a predicate for filtering equipmentslice.
// An error is returned if the input is empty or invalid.
func (i *EquipmentWhereInput) P() (predicate.Equipment, error) {
	var predicates []predicate.Equipment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, equipment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Equipment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, equipment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Equipment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, equipment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, equipment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, equipment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, equipment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, equipment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, equipment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, equipment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, equipment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, equipment.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, equipment.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, equipment.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, equipment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, equipment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, equipment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, equipment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, equipment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, equipment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, equipment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, equipment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, equipment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, equipment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, equipment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, equipment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, equipment.NameContainsFold(*i.NameContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, equipment.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, equipment.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, equipment.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, equipment.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, equipment.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, equipment.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, equipment.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, equipment.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, equipment.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, equipment.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, equipment.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, equipment.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, equipment.ImageContainsFold(*i.ImageContainsFold))
	}

	if i.HasExercises != nil {
		p := equipment.HasExercises()
		if !*i.HasExercises {
			p = equipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, equipment.HasExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEquipmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return equipment.And(predicates...), nil
	}
}

// ExerciseWhereInput represents a where input for filtering Exercise queries.
type ExerciseWhereInput struct {
	Predicates []predicate.Exercise  `json:"-"`
	Not        *ExerciseWhereInput   `json:"not,omitempty"`
	Or         []*ExerciseWhereInput `json:"or,omitempty"`
	And        []*ExerciseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "how_to" field predicates.
	HowTo             *string  `json:"howTo,omitempty"`
	HowToNEQ          *string  `json:"howToNEQ,omitempty"`
	HowToIn           []string `json:"howToIn,omitempty"`
	HowToNotIn        []string `json:"howToNotIn,omitempty"`
	HowToGT           *string  `json:"howToGT,omitempty"`
	HowToGTE          *string  `json:"howToGTE,omitempty"`
	HowToLT           *string  `json:"howToLT,omitempty"`
	HowToLTE          *string  `json:"howToLTE,omitempty"`
	HowToContains     *string  `json:"howToContains,omitempty"`
	HowToHasPrefix    *string  `json:"howToHasPrefix,omitempty"`
	HowToHasSuffix    *string  `json:"howToHasSuffix,omitempty"`
	HowToIsNil        bool     `json:"howToIsNil,omitempty"`
	HowToNotNil       bool     `json:"howToNotNil,omitempty"`
	HowToEqualFold    *string  `json:"howToEqualFold,omitempty"`
	HowToContainsFold *string  `json:"howToContainsFold,omitempty"`

	// "equipment_id" field predicates.
	EquipmentID             *string  `json:"equipmentID,omitempty"`
	EquipmentIDNEQ          *string  `json:"equipmentIDNEQ,omitempty"`
	EquipmentIDIn           []string `json:"equipmentIDIn,omitempty"`
	EquipmentIDNotIn        []string `json:"equipmentIDNotIn,omitempty"`
	EquipmentIDGT           *string  `json:"equipmentIDGT,omitempty"`
	EquipmentIDGTE          *string  `json:"equipmentIDGTE,omitempty"`
	EquipmentIDLT           *string  `json:"equipmentIDLT,omitempty"`
	EquipmentIDLTE          *string  `json:"equipmentIDLTE,omitempty"`
	EquipmentIDContains     *string  `json:"equipmentIDContains,omitempty"`
	EquipmentIDHasPrefix    *string  `json:"equipmentIDHasPrefix,omitempty"`
	EquipmentIDHasSuffix    *string  `json:"equipmentIDHasSuffix,omitempty"`
	EquipmentIDIsNil        bool     `json:"equipmentIDIsNil,omitempty"`
	EquipmentIDNotNil       bool     `json:"equipmentIDNotNil,omitempty"`
	EquipmentIDEqualFold    *string  `json:"equipmentIDEqualFold,omitempty"`
	EquipmentIDContainsFold *string  `json:"equipmentIDContainsFold,omitempty"`

	// "muscles_group_id" field predicates.
	MusclesGroupID             *string  `json:"musclesGroupID,omitempty"`
	MusclesGroupIDNEQ          *string  `json:"musclesGroupIDNEQ,omitempty"`
	MusclesGroupIDIn           []string `json:"musclesGroupIDIn,omitempty"`
	MusclesGroupIDNotIn        []string `json:"musclesGroupIDNotIn,omitempty"`
	MusclesGroupIDGT           *string  `json:"musclesGroupIDGT,omitempty"`
	MusclesGroupIDGTE          *string  `json:"musclesGroupIDGTE,omitempty"`
	MusclesGroupIDLT           *string  `json:"musclesGroupIDLT,omitempty"`
	MusclesGroupIDLTE          *string  `json:"musclesGroupIDLTE,omitempty"`
	MusclesGroupIDContains     *string  `json:"musclesGroupIDContains,omitempty"`
	MusclesGroupIDHasPrefix    *string  `json:"musclesGroupIDHasPrefix,omitempty"`
	MusclesGroupIDHasSuffix    *string  `json:"musclesGroupIDHasSuffix,omitempty"`
	MusclesGroupIDIsNil        bool     `json:"musclesGroupIDIsNil,omitempty"`
	MusclesGroupIDNotNil       bool     `json:"musclesGroupIDNotNil,omitempty"`
	MusclesGroupIDEqualFold    *string  `json:"musclesGroupIDEqualFold,omitempty"`
	MusclesGroupIDContainsFold *string  `json:"musclesGroupIDContainsFold,omitempty"`

	// "exercise_type_id" field predicates.
	ExerciseTypeID             *string  `json:"exerciseTypeID,omitempty"`
	ExerciseTypeIDNEQ          *string  `json:"exerciseTypeIDNEQ,omitempty"`
	ExerciseTypeIDIn           []string `json:"exerciseTypeIDIn,omitempty"`
	ExerciseTypeIDNotIn        []string `json:"exerciseTypeIDNotIn,omitempty"`
	ExerciseTypeIDGT           *string  `json:"exerciseTypeIDGT,omitempty"`
	ExerciseTypeIDGTE          *string  `json:"exerciseTypeIDGTE,omitempty"`
	ExerciseTypeIDLT           *string  `json:"exerciseTypeIDLT,omitempty"`
	ExerciseTypeIDLTE          *string  `json:"exerciseTypeIDLTE,omitempty"`
	ExerciseTypeIDContains     *string  `json:"exerciseTypeIDContains,omitempty"`
	ExerciseTypeIDHasPrefix    *string  `json:"exerciseTypeIDHasPrefix,omitempty"`
	ExerciseTypeIDHasSuffix    *string  `json:"exerciseTypeIDHasSuffix,omitempty"`
	ExerciseTypeIDIsNil        bool     `json:"exerciseTypeIDIsNil,omitempty"`
	ExerciseTypeIDNotNil       bool     `json:"exerciseTypeIDNotNil,omitempty"`
	ExerciseTypeIDEqualFold    *string  `json:"exerciseTypeIDEqualFold,omitempty"`
	ExerciseTypeIDContainsFold *string  `json:"exerciseTypeIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "workout_logs" edge predicates.
	HasWorkoutLogs     *bool                   `json:"hasWorkoutLogs,omitempty"`
	HasWorkoutLogsWith []*WorkoutLogWhereInput `json:"hasWorkoutLogsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "equipments" edge predicates.
	HasEquipments     *bool                  `json:"hasEquipments,omitempty"`
	HasEquipmentsWith []*EquipmentWhereInput `json:"hasEquipmentsWith,omitempty"`

	// "muscles_groups" edge predicates.
	HasMusclesGroups     *bool                     `json:"hasMusclesGroups,omitempty"`
	HasMusclesGroupsWith []*MusclesGroupWhereInput `json:"hasMusclesGroupsWith,omitempty"`

	// "exercise_types" edge predicates.
	HasExerciseTypes     *bool                     `json:"hasExerciseTypes,omitempty"`
	HasExerciseTypesWith []*ExerciseTypeWhereInput `json:"hasExerciseTypesWith,omitempty"`

	// "routines" edge predicates.
	HasRoutines     *bool                `json:"hasRoutines,omitempty"`
	HasRoutinesWith []*RoutineWhereInput `json:"hasRoutinesWith,omitempty"`

	// "routine_exercises" edge predicates.
	HasRoutineExercises     *bool                        `json:"hasRoutineExercises,omitempty"`
	HasRoutineExercisesWith []*RoutineExerciseWhereInput `json:"hasRoutineExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExerciseWhereInput) AddPredicates(predicates ...predicate.Exercise) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExerciseWhereInput filter on the ExerciseQuery builder.
func (i *ExerciseWhereInput) Filter(q *ExerciseQuery) (*ExerciseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExerciseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExerciseWhereInput is returned in case the ExerciseWhereInput is empty.
var ErrEmptyExerciseWhereInput = errors.New("ent: empty predicate ExerciseWhereInput")

// P returns a predicate for filtering exercises.
// An error is returned if the input is empty or invalid.
func (i *ExerciseWhereInput) P() (predicate.Exercise, error) {
	var predicates []predicate.Exercise
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exercise.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exercise, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exercise.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exercise, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exercise.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exercise.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exercise.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exercise.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exercise.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exercise.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exercise.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exercise.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exercise.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, exercise.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, exercise.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, exercise.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exercise.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exercise.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exercise.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exercise.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exercise.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exercise.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exercise.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exercise.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exercise.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exercise.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exercise.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exercise.NameContainsFold(*i.NameContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, exercise.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, exercise.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, exercise.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, exercise.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, exercise.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, exercise.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, exercise.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, exercise.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, exercise.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, exercise.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, exercise.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, exercise.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, exercise.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, exercise.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, exercise.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.HowTo != nil {
		predicates = append(predicates, exercise.HowToEQ(*i.HowTo))
	}
	if i.HowToNEQ != nil {
		predicates = append(predicates, exercise.HowToNEQ(*i.HowToNEQ))
	}
	if len(i.HowToIn) > 0 {
		predicates = append(predicates, exercise.HowToIn(i.HowToIn...))
	}
	if len(i.HowToNotIn) > 0 {
		predicates = append(predicates, exercise.HowToNotIn(i.HowToNotIn...))
	}
	if i.HowToGT != nil {
		predicates = append(predicates, exercise.HowToGT(*i.HowToGT))
	}
	if i.HowToGTE != nil {
		predicates = append(predicates, exercise.HowToGTE(*i.HowToGTE))
	}
	if i.HowToLT != nil {
		predicates = append(predicates, exercise.HowToLT(*i.HowToLT))
	}
	if i.HowToLTE != nil {
		predicates = append(predicates, exercise.HowToLTE(*i.HowToLTE))
	}
	if i.HowToContains != nil {
		predicates = append(predicates, exercise.HowToContains(*i.HowToContains))
	}
	if i.HowToHasPrefix != nil {
		predicates = append(predicates, exercise.HowToHasPrefix(*i.HowToHasPrefix))
	}
	if i.HowToHasSuffix != nil {
		predicates = append(predicates, exercise.HowToHasSuffix(*i.HowToHasSuffix))
	}
	if i.HowToIsNil {
		predicates = append(predicates, exercise.HowToIsNil())
	}
	if i.HowToNotNil {
		predicates = append(predicates, exercise.HowToNotNil())
	}
	if i.HowToEqualFold != nil {
		predicates = append(predicates, exercise.HowToEqualFold(*i.HowToEqualFold))
	}
	if i.HowToContainsFold != nil {
		predicates = append(predicates, exercise.HowToContainsFold(*i.HowToContainsFold))
	}
	if i.EquipmentID != nil {
		predicates = append(predicates, exercise.EquipmentIDEQ(*i.EquipmentID))
	}
	if i.EquipmentIDNEQ != nil {
		predicates = append(predicates, exercise.EquipmentIDNEQ(*i.EquipmentIDNEQ))
	}
	if len(i.EquipmentIDIn) > 0 {
		predicates = append(predicates, exercise.EquipmentIDIn(i.EquipmentIDIn...))
	}
	if len(i.EquipmentIDNotIn) > 0 {
		predicates = append(predicates, exercise.EquipmentIDNotIn(i.EquipmentIDNotIn...))
	}
	if i.EquipmentIDGT != nil {
		predicates = append(predicates, exercise.EquipmentIDGT(*i.EquipmentIDGT))
	}
	if i.EquipmentIDGTE != nil {
		predicates = append(predicates, exercise.EquipmentIDGTE(*i.EquipmentIDGTE))
	}
	if i.EquipmentIDLT != nil {
		predicates = append(predicates, exercise.EquipmentIDLT(*i.EquipmentIDLT))
	}
	if i.EquipmentIDLTE != nil {
		predicates = append(predicates, exercise.EquipmentIDLTE(*i.EquipmentIDLTE))
	}
	if i.EquipmentIDContains != nil {
		predicates = append(predicates, exercise.EquipmentIDContains(*i.EquipmentIDContains))
	}
	if i.EquipmentIDHasPrefix != nil {
		predicates = append(predicates, exercise.EquipmentIDHasPrefix(*i.EquipmentIDHasPrefix))
	}
	if i.EquipmentIDHasSuffix != nil {
		predicates = append(predicates, exercise.EquipmentIDHasSuffix(*i.EquipmentIDHasSuffix))
	}
	if i.EquipmentIDIsNil {
		predicates = append(predicates, exercise.EquipmentIDIsNil())
	}
	if i.EquipmentIDNotNil {
		predicates = append(predicates, exercise.EquipmentIDNotNil())
	}
	if i.EquipmentIDEqualFold != nil {
		predicates = append(predicates, exercise.EquipmentIDEqualFold(*i.EquipmentIDEqualFold))
	}
	if i.EquipmentIDContainsFold != nil {
		predicates = append(predicates, exercise.EquipmentIDContainsFold(*i.EquipmentIDContainsFold))
	}
	if i.MusclesGroupID != nil {
		predicates = append(predicates, exercise.MusclesGroupIDEQ(*i.MusclesGroupID))
	}
	if i.MusclesGroupIDNEQ != nil {
		predicates = append(predicates, exercise.MusclesGroupIDNEQ(*i.MusclesGroupIDNEQ))
	}
	if len(i.MusclesGroupIDIn) > 0 {
		predicates = append(predicates, exercise.MusclesGroupIDIn(i.MusclesGroupIDIn...))
	}
	if len(i.MusclesGroupIDNotIn) > 0 {
		predicates = append(predicates, exercise.MusclesGroupIDNotIn(i.MusclesGroupIDNotIn...))
	}
	if i.MusclesGroupIDGT != nil {
		predicates = append(predicates, exercise.MusclesGroupIDGT(*i.MusclesGroupIDGT))
	}
	if i.MusclesGroupIDGTE != nil {
		predicates = append(predicates, exercise.MusclesGroupIDGTE(*i.MusclesGroupIDGTE))
	}
	if i.MusclesGroupIDLT != nil {
		predicates = append(predicates, exercise.MusclesGroupIDLT(*i.MusclesGroupIDLT))
	}
	if i.MusclesGroupIDLTE != nil {
		predicates = append(predicates, exercise.MusclesGroupIDLTE(*i.MusclesGroupIDLTE))
	}
	if i.MusclesGroupIDContains != nil {
		predicates = append(predicates, exercise.MusclesGroupIDContains(*i.MusclesGroupIDContains))
	}
	if i.MusclesGroupIDHasPrefix != nil {
		predicates = append(predicates, exercise.MusclesGroupIDHasPrefix(*i.MusclesGroupIDHasPrefix))
	}
	if i.MusclesGroupIDHasSuffix != nil {
		predicates = append(predicates, exercise.MusclesGroupIDHasSuffix(*i.MusclesGroupIDHasSuffix))
	}
	if i.MusclesGroupIDIsNil {
		predicates = append(predicates, exercise.MusclesGroupIDIsNil())
	}
	if i.MusclesGroupIDNotNil {
		predicates = append(predicates, exercise.MusclesGroupIDNotNil())
	}
	if i.MusclesGroupIDEqualFold != nil {
		predicates = append(predicates, exercise.MusclesGroupIDEqualFold(*i.MusclesGroupIDEqualFold))
	}
	if i.MusclesGroupIDContainsFold != nil {
		predicates = append(predicates, exercise.MusclesGroupIDContainsFold(*i.MusclesGroupIDContainsFold))
	}
	if i.ExerciseTypeID != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDEQ(*i.ExerciseTypeID))
	}
	if i.ExerciseTypeIDNEQ != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDNEQ(*i.ExerciseTypeIDNEQ))
	}
	if len(i.ExerciseTypeIDIn) > 0 {
		predicates = append(predicates, exercise.ExerciseTypeIDIn(i.ExerciseTypeIDIn...))
	}
	if len(i.ExerciseTypeIDNotIn) > 0 {
		predicates = append(predicates, exercise.ExerciseTypeIDNotIn(i.ExerciseTypeIDNotIn...))
	}
	if i.ExerciseTypeIDGT != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDGT(*i.ExerciseTypeIDGT))
	}
	if i.ExerciseTypeIDGTE != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDGTE(*i.ExerciseTypeIDGTE))
	}
	if i.ExerciseTypeIDLT != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDLT(*i.ExerciseTypeIDLT))
	}
	if i.ExerciseTypeIDLTE != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDLTE(*i.ExerciseTypeIDLTE))
	}
	if i.ExerciseTypeIDContains != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDContains(*i.ExerciseTypeIDContains))
	}
	if i.ExerciseTypeIDHasPrefix != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDHasPrefix(*i.ExerciseTypeIDHasPrefix))
	}
	if i.ExerciseTypeIDHasSuffix != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDHasSuffix(*i.ExerciseTypeIDHasSuffix))
	}
	if i.ExerciseTypeIDIsNil {
		predicates = append(predicates, exercise.ExerciseTypeIDIsNil())
	}
	if i.ExerciseTypeIDNotNil {
		predicates = append(predicates, exercise.ExerciseTypeIDNotNil())
	}
	if i.ExerciseTypeIDEqualFold != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDEqualFold(*i.ExerciseTypeIDEqualFold))
	}
	if i.ExerciseTypeIDContainsFold != nil {
		predicates = append(predicates, exercise.ExerciseTypeIDContainsFold(*i.ExerciseTypeIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, exercise.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, exercise.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, exercise.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, exercise.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, exercise.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, exercise.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, exercise.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, exercise.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, exercise.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, exercise.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, exercise.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, exercise.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, exercise.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, exercise.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, exercise.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasWorkoutLogs != nil {
		p := exercise.HasWorkoutLogs()
		if !*i.HasWorkoutLogs {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkoutLogsWith) > 0 {
		with := make([]predicate.WorkoutLog, 0, len(i.HasWorkoutLogsWith))
		for _, w := range i.HasWorkoutLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkoutLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasWorkoutLogsWith(with...))
	}
	if i.HasUsers != nil {
		p := exercise.HasUsers()
		if !*i.HasUsers {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasUsersWith(with...))
	}
	if i.HasEquipments != nil {
		p := exercise.HasEquipments()
		if !*i.HasEquipments {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEquipmentsWith) > 0 {
		with := make([]predicate.Equipment, 0, len(i.HasEquipmentsWith))
		for _, w := range i.HasEquipmentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEquipmentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasEquipmentsWith(with...))
	}
	if i.HasMusclesGroups != nil {
		p := exercise.HasMusclesGroups()
		if !*i.HasMusclesGroups {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMusclesGroupsWith) > 0 {
		with := make([]predicate.MusclesGroup, 0, len(i.HasMusclesGroupsWith))
		for _, w := range i.HasMusclesGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMusclesGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasMusclesGroupsWith(with...))
	}
	if i.HasExerciseTypes != nil {
		p := exercise.HasExerciseTypes()
		if !*i.HasExerciseTypes {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExerciseTypesWith) > 0 {
		with := make([]predicate.ExerciseType, 0, len(i.HasExerciseTypesWith))
		for _, w := range i.HasExerciseTypesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExerciseTypesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasExerciseTypesWith(with...))
	}
	if i.HasRoutines != nil {
		p := exercise.HasRoutines()
		if !*i.HasRoutines {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutinesWith) > 0 {
		with := make([]predicate.Routine, 0, len(i.HasRoutinesWith))
		for _, w := range i.HasRoutinesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutinesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasRoutinesWith(with...))
	}
	if i.HasRoutineExercises != nil {
		p := exercise.HasRoutineExercises()
		if !*i.HasRoutineExercises {
			p = exercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutineExercisesWith) > 0 {
		with := make([]predicate.RoutineExercise, 0, len(i.HasRoutineExercisesWith))
		for _, w := range i.HasRoutineExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutineExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercise.HasRoutineExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExerciseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exercise.And(predicates...), nil
	}
}

// ExerciseTypeWhereInput represents a where input for filtering ExerciseType queries.
type ExerciseTypeWhereInput struct {
	Predicates []predicate.ExerciseType  `json:"-"`
	Not        *ExerciseTypeWhereInput   `json:"not,omitempty"`
	Or         []*ExerciseTypeWhereInput `json:"or,omitempty"`
	And        []*ExerciseTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExerciseTypeWhereInput) AddPredicates(predicates ...predicate.ExerciseType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExerciseTypeWhereInput filter on the ExerciseTypeQuery builder.
func (i *ExerciseTypeWhereInput) Filter(q *ExerciseTypeQuery) (*ExerciseTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExerciseTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExerciseTypeWhereInput is returned in case the ExerciseTypeWhereInput is empty.
var ErrEmptyExerciseTypeWhereInput = errors.New("ent: empty predicate ExerciseTypeWhereInput")

// P returns a predicate for filtering exercisetypes.
// An error is returned if the input is empty or invalid.
func (i *ExerciseTypeWhereInput) P() (predicate.ExerciseType, error) {
	var predicates []predicate.ExerciseType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exercisetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ExerciseType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exercisetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ExerciseType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exercisetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exercisetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exercisetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exercisetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exercisetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exercisetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exercisetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exercisetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exercisetype.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, exercisetype.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, exercisetype.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, exercisetype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exercisetype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exercisetype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exercisetype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exercisetype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exercisetype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exercisetype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exercisetype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exercisetype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exercisetype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exercisetype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exercisetype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exercisetype.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, exercisetype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, exercisetype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, exercisetype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, exercisetype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, exercisetype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, exercisetype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, exercisetype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, exercisetype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, exercisetype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, exercisetype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, exercisetype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, exercisetype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, exercisetype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasExercises != nil {
		p := exercisetype.HasExercises()
		if !*i.HasExercises {
			p = exercisetype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exercisetype.HasExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExerciseTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exercisetype.And(predicates...), nil
	}
}

// MusclesGroupWhereInput represents a where input for filtering MusclesGroup queries.
type MusclesGroupWhereInput struct {
	Predicates []predicate.MusclesGroup  `json:"-"`
	Not        *MusclesGroupWhereInput   `json:"not,omitempty"`
	Or         []*MusclesGroupWhereInput `json:"or,omitempty"`
	And        []*MusclesGroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MusclesGroupWhereInput) AddPredicates(predicates ...predicate.MusclesGroup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MusclesGroupWhereInput filter on the MusclesGroupQuery builder.
func (i *MusclesGroupWhereInput) Filter(q *MusclesGroupQuery) (*MusclesGroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMusclesGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMusclesGroupWhereInput is returned in case the MusclesGroupWhereInput is empty.
var ErrEmptyMusclesGroupWhereInput = errors.New("ent: empty predicate MusclesGroupWhereInput")

// P returns a predicate for filtering musclesgroups.
// An error is returned if the input is empty or invalid.
func (i *MusclesGroupWhereInput) P() (predicate.MusclesGroup, error) {
	var predicates []predicate.MusclesGroup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, musclesgroup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.MusclesGroup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, musclesgroup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.MusclesGroup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, musclesgroup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, musclesgroup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, musclesgroup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, musclesgroup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, musclesgroup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, musclesgroup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, musclesgroup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, musclesgroup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, musclesgroup.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, musclesgroup.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, musclesgroup.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, musclesgroup.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, musclesgroup.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, musclesgroup.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, musclesgroup.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, musclesgroup.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, musclesgroup.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, musclesgroup.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, musclesgroup.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, musclesgroup.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, musclesgroup.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, musclesgroup.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, musclesgroup.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, musclesgroup.NameContainsFold(*i.NameContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, musclesgroup.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, musclesgroup.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, musclesgroup.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, musclesgroup.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, musclesgroup.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, musclesgroup.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, musclesgroup.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, musclesgroup.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, musclesgroup.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, musclesgroup.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, musclesgroup.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, musclesgroup.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, musclesgroup.ImageContainsFold(*i.ImageContainsFold))
	}

	if i.HasExercises != nil {
		p := musclesgroup.HasExercises()
		if !*i.HasExercises {
			p = musclesgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, musclesgroup.HasExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMusclesGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return musclesgroup.And(predicates...), nil
	}
}

// RoutineWhereInput represents a where input for filtering Routine queries.
type RoutineWhereInput struct {
	Predicates []predicate.Routine  `json:"-"`
	Not        *RoutineWhereInput   `json:"not,omitempty"`
	Or         []*RoutineWhereInput `json:"or,omitempty"`
	And        []*RoutineWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "routine_exercises" edge predicates.
	HasRoutineExercises     *bool                        `json:"hasRoutineExercises,omitempty"`
	HasRoutineExercisesWith []*RoutineExerciseWhereInput `json:"hasRoutineExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoutineWhereInput) AddPredicates(predicates ...predicate.Routine) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoutineWhereInput filter on the RoutineQuery builder.
func (i *RoutineWhereInput) Filter(q *RoutineQuery) (*RoutineQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoutineWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoutineWhereInput is returned in case the RoutineWhereInput is empty.
var ErrEmptyRoutineWhereInput = errors.New("ent: empty predicate RoutineWhereInput")

// P returns a predicate for filtering routines.
// An error is returned if the input is empty or invalid.
func (i *RoutineWhereInput) P() (predicate.Routine, error) {
	var predicates []predicate.Routine
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, routine.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Routine, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, routine.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Routine, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, routine.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, routine.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, routine.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, routine.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, routine.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, routine.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, routine.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, routine.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, routine.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, routine.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, routine.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, routine.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, routine.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, routine.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, routine.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, routine.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, routine.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, routine.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, routine.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, routine.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, routine.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, routine.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, routine.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, routine.NameContainsFold(*i.NameContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, routine.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, routine.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, routine.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, routine.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, routine.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, routine.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, routine.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, routine.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, routine.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, routine.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, routine.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, routine.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, routine.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, routine.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, routine.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasExercises != nil {
		p := routine.HasExercises()
		if !*i.HasExercises {
			p = routine.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routine.HasExercisesWith(with...))
	}
	if i.HasUsers != nil {
		p := routine.HasUsers()
		if !*i.HasUsers {
			p = routine.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routine.HasUsersWith(with...))
	}
	if i.HasRoutineExercises != nil {
		p := routine.HasRoutineExercises()
		if !*i.HasRoutineExercises {
			p = routine.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutineExercisesWith) > 0 {
		with := make([]predicate.RoutineExercise, 0, len(i.HasRoutineExercisesWith))
		for _, w := range i.HasRoutineExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutineExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routine.HasRoutineExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoutineWhereInput
	case 1:
		return predicates[0], nil
	default:
		return routine.And(predicates...), nil
	}
}

// RoutineExerciseWhereInput represents a where input for filtering RoutineExercise queries.
type RoutineExerciseWhereInput struct {
	Predicates []predicate.RoutineExercise  `json:"-"`
	Not        *RoutineExerciseWhereInput   `json:"not,omitempty"`
	Or         []*RoutineExerciseWhereInput `json:"or,omitempty"`
	And        []*RoutineExerciseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "rest_timer" field predicates.
	RestTimer       *int  `json:"restTimer,omitempty"`
	RestTimerNEQ    *int  `json:"restTimerNEQ,omitempty"`
	RestTimerIn     []int `json:"restTimerIn,omitempty"`
	RestTimerNotIn  []int `json:"restTimerNotIn,omitempty"`
	RestTimerGT     *int  `json:"restTimerGT,omitempty"`
	RestTimerGTE    *int  `json:"restTimerGTE,omitempty"`
	RestTimerLT     *int  `json:"restTimerLT,omitempty"`
	RestTimerLTE    *int  `json:"restTimerLTE,omitempty"`
	RestTimerIsNil  bool  `json:"restTimerIsNil,omitempty"`
	RestTimerNotNil bool  `json:"restTimerNotNil,omitempty"`

	// "routine_id" field predicates.
	RoutineID             *string  `json:"routineID,omitempty"`
	RoutineIDNEQ          *string  `json:"routineIDNEQ,omitempty"`
	RoutineIDIn           []string `json:"routineIDIn,omitempty"`
	RoutineIDNotIn        []string `json:"routineIDNotIn,omitempty"`
	RoutineIDGT           *string  `json:"routineIDGT,omitempty"`
	RoutineIDGTE          *string  `json:"routineIDGTE,omitempty"`
	RoutineIDLT           *string  `json:"routineIDLT,omitempty"`
	RoutineIDLTE          *string  `json:"routineIDLTE,omitempty"`
	RoutineIDContains     *string  `json:"routineIDContains,omitempty"`
	RoutineIDHasPrefix    *string  `json:"routineIDHasPrefix,omitempty"`
	RoutineIDHasSuffix    *string  `json:"routineIDHasSuffix,omitempty"`
	RoutineIDEqualFold    *string  `json:"routineIDEqualFold,omitempty"`
	RoutineIDContainsFold *string  `json:"routineIDContainsFold,omitempty"`

	// "exercise_id" field predicates.
	ExerciseID             *string  `json:"exerciseID,omitempty"`
	ExerciseIDNEQ          *string  `json:"exerciseIDNEQ,omitempty"`
	ExerciseIDIn           []string `json:"exerciseIDIn,omitempty"`
	ExerciseIDNotIn        []string `json:"exerciseIDNotIn,omitempty"`
	ExerciseIDGT           *string  `json:"exerciseIDGT,omitempty"`
	ExerciseIDGTE          *string  `json:"exerciseIDGTE,omitempty"`
	ExerciseIDLT           *string  `json:"exerciseIDLT,omitempty"`
	ExerciseIDLTE          *string  `json:"exerciseIDLTE,omitempty"`
	ExerciseIDContains     *string  `json:"exerciseIDContains,omitempty"`
	ExerciseIDHasPrefix    *string  `json:"exerciseIDHasPrefix,omitempty"`
	ExerciseIDHasSuffix    *string  `json:"exerciseIDHasSuffix,omitempty"`
	ExerciseIDEqualFold    *string  `json:"exerciseIDEqualFold,omitempty"`
	ExerciseIDContainsFold *string  `json:"exerciseIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "routines" edge predicates.
	HasRoutines     *bool                `json:"hasRoutines,omitempty"`
	HasRoutinesWith []*RoutineWhereInput `json:"hasRoutinesWith,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoutineExerciseWhereInput) AddPredicates(predicates ...predicate.RoutineExercise) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoutineExerciseWhereInput filter on the RoutineExerciseQuery builder.
func (i *RoutineExerciseWhereInput) Filter(q *RoutineExerciseQuery) (*RoutineExerciseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoutineExerciseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoutineExerciseWhereInput is returned in case the RoutineExerciseWhereInput is empty.
var ErrEmptyRoutineExerciseWhereInput = errors.New("ent: empty predicate RoutineExerciseWhereInput")

// P returns a predicate for filtering routineexercises.
// An error is returned if the input is empty or invalid.
func (i *RoutineExerciseWhereInput) P() (predicate.RoutineExercise, error) {
	var predicates []predicate.RoutineExercise
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, routineexercise.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RoutineExercise, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, routineexercise.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RoutineExercise, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, routineexercise.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, routineexercise.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, routineexercise.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, routineexercise.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, routineexercise.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, routineexercise.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, routineexercise.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, routineexercise.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, routineexercise.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, routineexercise.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, routineexercise.IDContainsFold(*i.IDContainsFold))
	}
	if i.RestTimer != nil {
		predicates = append(predicates, routineexercise.RestTimerEQ(*i.RestTimer))
	}
	if i.RestTimerNEQ != nil {
		predicates = append(predicates, routineexercise.RestTimerNEQ(*i.RestTimerNEQ))
	}
	if len(i.RestTimerIn) > 0 {
		predicates = append(predicates, routineexercise.RestTimerIn(i.RestTimerIn...))
	}
	if len(i.RestTimerNotIn) > 0 {
		predicates = append(predicates, routineexercise.RestTimerNotIn(i.RestTimerNotIn...))
	}
	if i.RestTimerGT != nil {
		predicates = append(predicates, routineexercise.RestTimerGT(*i.RestTimerGT))
	}
	if i.RestTimerGTE != nil {
		predicates = append(predicates, routineexercise.RestTimerGTE(*i.RestTimerGTE))
	}
	if i.RestTimerLT != nil {
		predicates = append(predicates, routineexercise.RestTimerLT(*i.RestTimerLT))
	}
	if i.RestTimerLTE != nil {
		predicates = append(predicates, routineexercise.RestTimerLTE(*i.RestTimerLTE))
	}
	if i.RestTimerIsNil {
		predicates = append(predicates, routineexercise.RestTimerIsNil())
	}
	if i.RestTimerNotNil {
		predicates = append(predicates, routineexercise.RestTimerNotNil())
	}
	if i.RoutineID != nil {
		predicates = append(predicates, routineexercise.RoutineIDEQ(*i.RoutineID))
	}
	if i.RoutineIDNEQ != nil {
		predicates = append(predicates, routineexercise.RoutineIDNEQ(*i.RoutineIDNEQ))
	}
	if len(i.RoutineIDIn) > 0 {
		predicates = append(predicates, routineexercise.RoutineIDIn(i.RoutineIDIn...))
	}
	if len(i.RoutineIDNotIn) > 0 {
		predicates = append(predicates, routineexercise.RoutineIDNotIn(i.RoutineIDNotIn...))
	}
	if i.RoutineIDGT != nil {
		predicates = append(predicates, routineexercise.RoutineIDGT(*i.RoutineIDGT))
	}
	if i.RoutineIDGTE != nil {
		predicates = append(predicates, routineexercise.RoutineIDGTE(*i.RoutineIDGTE))
	}
	if i.RoutineIDLT != nil {
		predicates = append(predicates, routineexercise.RoutineIDLT(*i.RoutineIDLT))
	}
	if i.RoutineIDLTE != nil {
		predicates = append(predicates, routineexercise.RoutineIDLTE(*i.RoutineIDLTE))
	}
	if i.RoutineIDContains != nil {
		predicates = append(predicates, routineexercise.RoutineIDContains(*i.RoutineIDContains))
	}
	if i.RoutineIDHasPrefix != nil {
		predicates = append(predicates, routineexercise.RoutineIDHasPrefix(*i.RoutineIDHasPrefix))
	}
	if i.RoutineIDHasSuffix != nil {
		predicates = append(predicates, routineexercise.RoutineIDHasSuffix(*i.RoutineIDHasSuffix))
	}
	if i.RoutineIDEqualFold != nil {
		predicates = append(predicates, routineexercise.RoutineIDEqualFold(*i.RoutineIDEqualFold))
	}
	if i.RoutineIDContainsFold != nil {
		predicates = append(predicates, routineexercise.RoutineIDContainsFold(*i.RoutineIDContainsFold))
	}
	if i.ExerciseID != nil {
		predicates = append(predicates, routineexercise.ExerciseIDEQ(*i.ExerciseID))
	}
	if i.ExerciseIDNEQ != nil {
		predicates = append(predicates, routineexercise.ExerciseIDNEQ(*i.ExerciseIDNEQ))
	}
	if len(i.ExerciseIDIn) > 0 {
		predicates = append(predicates, routineexercise.ExerciseIDIn(i.ExerciseIDIn...))
	}
	if len(i.ExerciseIDNotIn) > 0 {
		predicates = append(predicates, routineexercise.ExerciseIDNotIn(i.ExerciseIDNotIn...))
	}
	if i.ExerciseIDGT != nil {
		predicates = append(predicates, routineexercise.ExerciseIDGT(*i.ExerciseIDGT))
	}
	if i.ExerciseIDGTE != nil {
		predicates = append(predicates, routineexercise.ExerciseIDGTE(*i.ExerciseIDGTE))
	}
	if i.ExerciseIDLT != nil {
		predicates = append(predicates, routineexercise.ExerciseIDLT(*i.ExerciseIDLT))
	}
	if i.ExerciseIDLTE != nil {
		predicates = append(predicates, routineexercise.ExerciseIDLTE(*i.ExerciseIDLTE))
	}
	if i.ExerciseIDContains != nil {
		predicates = append(predicates, routineexercise.ExerciseIDContains(*i.ExerciseIDContains))
	}
	if i.ExerciseIDHasPrefix != nil {
		predicates = append(predicates, routineexercise.ExerciseIDHasPrefix(*i.ExerciseIDHasPrefix))
	}
	if i.ExerciseIDHasSuffix != nil {
		predicates = append(predicates, routineexercise.ExerciseIDHasSuffix(*i.ExerciseIDHasSuffix))
	}
	if i.ExerciseIDEqualFold != nil {
		predicates = append(predicates, routineexercise.ExerciseIDEqualFold(*i.ExerciseIDEqualFold))
	}
	if i.ExerciseIDContainsFold != nil {
		predicates = append(predicates, routineexercise.ExerciseIDContainsFold(*i.ExerciseIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, routineexercise.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, routineexercise.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, routineexercise.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, routineexercise.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, routineexercise.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, routineexercise.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, routineexercise.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, routineexercise.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, routineexercise.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, routineexercise.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, routineexercise.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, routineexercise.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, routineexercise.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, routineexercise.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, routineexercise.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasRoutines != nil {
		p := routineexercise.HasRoutines()
		if !*i.HasRoutines {
			p = routineexercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutinesWith) > 0 {
		with := make([]predicate.Routine, 0, len(i.HasRoutinesWith))
		for _, w := range i.HasRoutinesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutinesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routineexercise.HasRoutinesWith(with...))
	}
	if i.HasExercises != nil {
		p := routineexercise.HasExercises()
		if !*i.HasExercises {
			p = routineexercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routineexercise.HasExercisesWith(with...))
	}
	if i.HasUsers != nil {
		p := routineexercise.HasUsers()
		if !*i.HasUsers {
			p = routineexercise.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, routineexercise.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoutineExerciseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return routineexercise.And(predicates...), nil
	}
}

// TokenWhereInput represents a where input for filtering Token queries.
type TokenWhereInput struct {
	Predicates []predicate.Token  `json:"-"`
	Not        *TokenWhereInput   `json:"not,omitempty"`
	Or         []*TokenWhereInput `json:"or,omitempty"`
	And        []*TokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "expiry" field predicates.
	Expiry             *string  `json:"expiry,omitempty"`
	ExpiryNEQ          *string  `json:"expiryNEQ,omitempty"`
	ExpiryIn           []string `json:"expiryIn,omitempty"`
	ExpiryNotIn        []string `json:"expiryNotIn,omitempty"`
	ExpiryGT           *string  `json:"expiryGT,omitempty"`
	ExpiryGTE          *string  `json:"expiryGTE,omitempty"`
	ExpiryLT           *string  `json:"expiryLT,omitempty"`
	ExpiryLTE          *string  `json:"expiryLTE,omitempty"`
	ExpiryContains     *string  `json:"expiryContains,omitempty"`
	ExpiryHasPrefix    *string  `json:"expiryHasPrefix,omitempty"`
	ExpiryHasSuffix    *string  `json:"expiryHasSuffix,omitempty"`
	ExpiryEqualFold    *string  `json:"expiryEqualFold,omitempty"`
	ExpiryContainsFold *string  `json:"expiryContainsFold,omitempty"`

	// "scope" field predicates.
	Scope             *string  `json:"scope,omitempty"`
	ScopeNEQ          *string  `json:"scopeNEQ,omitempty"`
	ScopeIn           []string `json:"scopeIn,omitempty"`
	ScopeNotIn        []string `json:"scopeNotIn,omitempty"`
	ScopeGT           *string  `json:"scopeGT,omitempty"`
	ScopeGTE          *string  `json:"scopeGTE,omitempty"`
	ScopeLT           *string  `json:"scopeLT,omitempty"`
	ScopeLTE          *string  `json:"scopeLTE,omitempty"`
	ScopeContains     *string  `json:"scopeContains,omitempty"`
	ScopeHasPrefix    *string  `json:"scopeHasPrefix,omitempty"`
	ScopeHasSuffix    *string  `json:"scopeHasSuffix,omitempty"`
	ScopeEqualFold    *string  `json:"scopeEqualFold,omitempty"`
	ScopeContainsFold *string  `json:"scopeContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TokenWhereInput) AddPredicates(predicates ...predicate.Token) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TokenWhereInput filter on the TokenQuery builder.
func (i *TokenWhereInput) Filter(q *TokenQuery) (*TokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTokenWhereInput is returned in case the TokenWhereInput is empty.
var ErrEmptyTokenWhereInput = errors.New("ent: empty predicate TokenWhereInput")

// P returns a predicate for filtering tokens.
// An error is returned if the input is empty or invalid.
func (i *TokenWhereInput) P() (predicate.Token, error) {
	var predicates []predicate.Token
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, token.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Token, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, token.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Token, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, token.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, token.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, token.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, token.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, token.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, token.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, token.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, token.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, token.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, token.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, token.IDContainsFold(*i.IDContainsFold))
	}
	if i.Expiry != nil {
		predicates = append(predicates, token.ExpiryEQ(*i.Expiry))
	}
	if i.ExpiryNEQ != nil {
		predicates = append(predicates, token.ExpiryNEQ(*i.ExpiryNEQ))
	}
	if len(i.ExpiryIn) > 0 {
		predicates = append(predicates, token.ExpiryIn(i.ExpiryIn...))
	}
	if len(i.ExpiryNotIn) > 0 {
		predicates = append(predicates, token.ExpiryNotIn(i.ExpiryNotIn...))
	}
	if i.ExpiryGT != nil {
		predicates = append(predicates, token.ExpiryGT(*i.ExpiryGT))
	}
	if i.ExpiryGTE != nil {
		predicates = append(predicates, token.ExpiryGTE(*i.ExpiryGTE))
	}
	if i.ExpiryLT != nil {
		predicates = append(predicates, token.ExpiryLT(*i.ExpiryLT))
	}
	if i.ExpiryLTE != nil {
		predicates = append(predicates, token.ExpiryLTE(*i.ExpiryLTE))
	}
	if i.ExpiryContains != nil {
		predicates = append(predicates, token.ExpiryContains(*i.ExpiryContains))
	}
	if i.ExpiryHasPrefix != nil {
		predicates = append(predicates, token.ExpiryHasPrefix(*i.ExpiryHasPrefix))
	}
	if i.ExpiryHasSuffix != nil {
		predicates = append(predicates, token.ExpiryHasSuffix(*i.ExpiryHasSuffix))
	}
	if i.ExpiryEqualFold != nil {
		predicates = append(predicates, token.ExpiryEqualFold(*i.ExpiryEqualFold))
	}
	if i.ExpiryContainsFold != nil {
		predicates = append(predicates, token.ExpiryContainsFold(*i.ExpiryContainsFold))
	}
	if i.Scope != nil {
		predicates = append(predicates, token.ScopeEQ(*i.Scope))
	}
	if i.ScopeNEQ != nil {
		predicates = append(predicates, token.ScopeNEQ(*i.ScopeNEQ))
	}
	if len(i.ScopeIn) > 0 {
		predicates = append(predicates, token.ScopeIn(i.ScopeIn...))
	}
	if len(i.ScopeNotIn) > 0 {
		predicates = append(predicates, token.ScopeNotIn(i.ScopeNotIn...))
	}
	if i.ScopeGT != nil {
		predicates = append(predicates, token.ScopeGT(*i.ScopeGT))
	}
	if i.ScopeGTE != nil {
		predicates = append(predicates, token.ScopeGTE(*i.ScopeGTE))
	}
	if i.ScopeLT != nil {
		predicates = append(predicates, token.ScopeLT(*i.ScopeLT))
	}
	if i.ScopeLTE != nil {
		predicates = append(predicates, token.ScopeLTE(*i.ScopeLTE))
	}
	if i.ScopeContains != nil {
		predicates = append(predicates, token.ScopeContains(*i.ScopeContains))
	}
	if i.ScopeHasPrefix != nil {
		predicates = append(predicates, token.ScopeHasPrefix(*i.ScopeHasPrefix))
	}
	if i.ScopeHasSuffix != nil {
		predicates = append(predicates, token.ScopeHasSuffix(*i.ScopeHasSuffix))
	}
	if i.ScopeEqualFold != nil {
		predicates = append(predicates, token.ScopeEqualFold(*i.ScopeEqualFold))
	}
	if i.ScopeContainsFold != nil {
		predicates = append(predicates, token.ScopeContainsFold(*i.ScopeContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, token.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, token.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, token.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, token.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, token.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, token.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, token.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, token.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, token.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, token.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, token.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, token.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, token.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, token.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, token.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasUsers != nil {
		p := token.HasUsers()
		if !*i.HasUsers {
			p = token.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, token.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return token.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "hashed_password" field predicates.
	HashedPassword             *string  `json:"hashedPassword,omitempty"`
	HashedPasswordNEQ          *string  `json:"hashedPasswordNEQ,omitempty"`
	HashedPasswordIn           []string `json:"hashedPasswordIn,omitempty"`
	HashedPasswordNotIn        []string `json:"hashedPasswordNotIn,omitempty"`
	HashedPasswordGT           *string  `json:"hashedPasswordGT,omitempty"`
	HashedPasswordGTE          *string  `json:"hashedPasswordGTE,omitempty"`
	HashedPasswordLT           *string  `json:"hashedPasswordLT,omitempty"`
	HashedPasswordLTE          *string  `json:"hashedPasswordLTE,omitempty"`
	HashedPasswordContains     *string  `json:"hashedPasswordContains,omitempty"`
	HashedPasswordHasPrefix    *string  `json:"hashedPasswordHasPrefix,omitempty"`
	HashedPasswordHasSuffix    *string  `json:"hashedPasswordHasSuffix,omitempty"`
	HashedPasswordEqualFold    *string  `json:"hashedPasswordEqualFold,omitempty"`
	HashedPasswordContainsFold *string  `json:"hashedPasswordContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt             *string  `json:"createdAt,omitempty"`
	CreatedAtNEQ          *string  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn           []string `json:"createdAtIn,omitempty"`
	CreatedAtNotIn        []string `json:"createdAtNotIn,omitempty"`
	CreatedAtGT           *string  `json:"createdAtGT,omitempty"`
	CreatedAtGTE          *string  `json:"createdAtGTE,omitempty"`
	CreatedAtLT           *string  `json:"createdAtLT,omitempty"`
	CreatedAtLTE          *string  `json:"createdAtLTE,omitempty"`
	CreatedAtContains     *string  `json:"createdAtContains,omitempty"`
	CreatedAtHasPrefix    *string  `json:"createdAtHasPrefix,omitempty"`
	CreatedAtHasSuffix    *string  `json:"createdAtHasSuffix,omitempty"`
	CreatedAtEqualFold    *string  `json:"createdAtEqualFold,omitempty"`
	CreatedAtContainsFold *string  `json:"createdAtContainsFold,omitempty"`

	// "activated" field predicates.
	Activated      *int  `json:"activated,omitempty"`
	ActivatedNEQ   *int  `json:"activatedNEQ,omitempty"`
	ActivatedIn    []int `json:"activatedIn,omitempty"`
	ActivatedNotIn []int `json:"activatedNotIn,omitempty"`
	ActivatedGT    *int  `json:"activatedGT,omitempty"`
	ActivatedGTE   *int  `json:"activatedGTE,omitempty"`
	ActivatedLT    *int  `json:"activatedLT,omitempty"`
	ActivatedLTE   *int  `json:"activatedLTE,omitempty"`

	// "version" field predicates.
	Version      *int  `json:"version,omitempty"`
	VersionNEQ   *int  `json:"versionNEQ,omitempty"`
	VersionIn    []int `json:"versionIn,omitempty"`
	VersionNotIn []int `json:"versionNotIn,omitempty"`
	VersionGT    *int  `json:"versionGT,omitempty"`
	VersionGTE   *int  `json:"versionGTE,omitempty"`
	VersionLT    *int  `json:"versionLT,omitempty"`
	VersionLTE   *int  `json:"versionLTE,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool              `json:"hasTokens,omitempty"`
	HasTokensWith []*TokenWhereInput `json:"hasTokensWith,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`

	// "routines" edge predicates.
	HasRoutines     *bool                `json:"hasRoutines,omitempty"`
	HasRoutinesWith []*RoutineWhereInput `json:"hasRoutinesWith,omitempty"`

	// "workouts" edge predicates.
	HasWorkouts     *bool                `json:"hasWorkouts,omitempty"`
	HasWorkoutsWith []*WorkoutWhereInput `json:"hasWorkoutsWith,omitempty"`

	// "workout_logs" edge predicates.
	HasWorkoutLogs     *bool                   `json:"hasWorkoutLogs,omitempty"`
	HasWorkoutLogsWith []*WorkoutLogWhereInput `json:"hasWorkoutLogsWith,omitempty"`

	// "routine_exercises" edge predicates.
	HasRoutineExercises     *bool                        `json:"hasRoutineExercises,omitempty"`
	HasRoutineExercisesWith []*RoutineExerciseWhereInput `json:"hasRoutineExercisesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, user.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, user.IDContainsFold(*i.IDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.HashedPassword != nil {
		predicates = append(predicates, user.HashedPasswordEQ(*i.HashedPassword))
	}
	if i.HashedPasswordNEQ != nil {
		predicates = append(predicates, user.HashedPasswordNEQ(*i.HashedPasswordNEQ))
	}
	if len(i.HashedPasswordIn) > 0 {
		predicates = append(predicates, user.HashedPasswordIn(i.HashedPasswordIn...))
	}
	if len(i.HashedPasswordNotIn) > 0 {
		predicates = append(predicates, user.HashedPasswordNotIn(i.HashedPasswordNotIn...))
	}
	if i.HashedPasswordGT != nil {
		predicates = append(predicates, user.HashedPasswordGT(*i.HashedPasswordGT))
	}
	if i.HashedPasswordGTE != nil {
		predicates = append(predicates, user.HashedPasswordGTE(*i.HashedPasswordGTE))
	}
	if i.HashedPasswordLT != nil {
		predicates = append(predicates, user.HashedPasswordLT(*i.HashedPasswordLT))
	}
	if i.HashedPasswordLTE != nil {
		predicates = append(predicates, user.HashedPasswordLTE(*i.HashedPasswordLTE))
	}
	if i.HashedPasswordContains != nil {
		predicates = append(predicates, user.HashedPasswordContains(*i.HashedPasswordContains))
	}
	if i.HashedPasswordHasPrefix != nil {
		predicates = append(predicates, user.HashedPasswordHasPrefix(*i.HashedPasswordHasPrefix))
	}
	if i.HashedPasswordHasSuffix != nil {
		predicates = append(predicates, user.HashedPasswordHasSuffix(*i.HashedPasswordHasSuffix))
	}
	if i.HashedPasswordEqualFold != nil {
		predicates = append(predicates, user.HashedPasswordEqualFold(*i.HashedPasswordEqualFold))
	}
	if i.HashedPasswordContainsFold != nil {
		predicates = append(predicates, user.HashedPasswordContainsFold(*i.HashedPasswordContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtContains != nil {
		predicates = append(predicates, user.CreatedAtContains(*i.CreatedAtContains))
	}
	if i.CreatedAtHasPrefix != nil {
		predicates = append(predicates, user.CreatedAtHasPrefix(*i.CreatedAtHasPrefix))
	}
	if i.CreatedAtHasSuffix != nil {
		predicates = append(predicates, user.CreatedAtHasSuffix(*i.CreatedAtHasSuffix))
	}
	if i.CreatedAtEqualFold != nil {
		predicates = append(predicates, user.CreatedAtEqualFold(*i.CreatedAtEqualFold))
	}
	if i.CreatedAtContainsFold != nil {
		predicates = append(predicates, user.CreatedAtContainsFold(*i.CreatedAtContainsFold))
	}
	if i.Activated != nil {
		predicates = append(predicates, user.ActivatedEQ(*i.Activated))
	}
	if i.ActivatedNEQ != nil {
		predicates = append(predicates, user.ActivatedNEQ(*i.ActivatedNEQ))
	}
	if len(i.ActivatedIn) > 0 {
		predicates = append(predicates, user.ActivatedIn(i.ActivatedIn...))
	}
	if len(i.ActivatedNotIn) > 0 {
		predicates = append(predicates, user.ActivatedNotIn(i.ActivatedNotIn...))
	}
	if i.ActivatedGT != nil {
		predicates = append(predicates, user.ActivatedGT(*i.ActivatedGT))
	}
	if i.ActivatedGTE != nil {
		predicates = append(predicates, user.ActivatedGTE(*i.ActivatedGTE))
	}
	if i.ActivatedLT != nil {
		predicates = append(predicates, user.ActivatedLT(*i.ActivatedLT))
	}
	if i.ActivatedLTE != nil {
		predicates = append(predicates, user.ActivatedLTE(*i.ActivatedLTE))
	}
	if i.Version != nil {
		predicates = append(predicates, user.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, user.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, user.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, user.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, user.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, user.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, user.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, user.VersionLTE(*i.VersionLTE))
	}

	if i.HasTokens != nil {
		p := user.HasTokens()
		if !*i.HasTokens {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.Token, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTokensWith(with...))
	}
	if i.HasExercises != nil {
		p := user.HasExercises()
		if !*i.HasExercises {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasExercisesWith(with...))
	}
	if i.HasRoutines != nil {
		p := user.HasRoutines()
		if !*i.HasRoutines {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutinesWith) > 0 {
		with := make([]predicate.Routine, 0, len(i.HasRoutinesWith))
		for _, w := range i.HasRoutinesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutinesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRoutinesWith(with...))
	}
	if i.HasWorkouts != nil {
		p := user.HasWorkouts()
		if !*i.HasWorkouts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkoutsWith) > 0 {
		with := make([]predicate.Workout, 0, len(i.HasWorkoutsWith))
		for _, w := range i.HasWorkoutsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkoutsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkoutsWith(with...))
	}
	if i.HasWorkoutLogs != nil {
		p := user.HasWorkoutLogs()
		if !*i.HasWorkoutLogs {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkoutLogsWith) > 0 {
		with := make([]predicate.WorkoutLog, 0, len(i.HasWorkoutLogsWith))
		for _, w := range i.HasWorkoutLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkoutLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkoutLogsWith(with...))
	}
	if i.HasRoutineExercises != nil {
		p := user.HasRoutineExercises()
		if !*i.HasRoutineExercises {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoutineExercisesWith) > 0 {
		with := make([]predicate.RoutineExercise, 0, len(i.HasRoutineExercisesWith))
		for _, w := range i.HasRoutineExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoutineExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRoutineExercisesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// WorkoutWhereInput represents a where input for filtering Workout queries.
type WorkoutWhereInput struct {
	Predicates []predicate.Workout  `json:"-"`
	Not        *WorkoutWhereInput   `json:"not,omitempty"`
	Or         []*WorkoutWhereInput `json:"or,omitempty"`
	And        []*WorkoutWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "volume" field predicates.
	Volume      *int  `json:"volume,omitempty"`
	VolumeNEQ   *int  `json:"volumeNEQ,omitempty"`
	VolumeIn    []int `json:"volumeIn,omitempty"`
	VolumeNotIn []int `json:"volumeNotIn,omitempty"`
	VolumeGT    *int  `json:"volumeGT,omitempty"`
	VolumeGTE   *int  `json:"volumeGTE,omitempty"`
	VolumeLT    *int  `json:"volumeLT,omitempty"`
	VolumeLTE   *int  `json:"volumeLTE,omitempty"`

	// "reps" field predicates.
	Reps      *int  `json:"reps,omitempty"`
	RepsNEQ   *int  `json:"repsNEQ,omitempty"`
	RepsIn    []int `json:"repsIn,omitempty"`
	RepsNotIn []int `json:"repsNotIn,omitempty"`
	RepsGT    *int  `json:"repsGT,omitempty"`
	RepsGTE   *int  `json:"repsGTE,omitempty"`
	RepsLT    *int  `json:"repsLT,omitempty"`
	RepsLTE   *int  `json:"repsLTE,omitempty"`

	// "time" field predicates.
	Time             *string  `json:"time,omitempty"`
	TimeNEQ          *string  `json:"timeNEQ,omitempty"`
	TimeIn           []string `json:"timeIn,omitempty"`
	TimeNotIn        []string `json:"timeNotIn,omitempty"`
	TimeGT           *string  `json:"timeGT,omitempty"`
	TimeGTE          *string  `json:"timeGTE,omitempty"`
	TimeLT           *string  `json:"timeLT,omitempty"`
	TimeLTE          *string  `json:"timeLTE,omitempty"`
	TimeContains     *string  `json:"timeContains,omitempty"`
	TimeHasPrefix    *string  `json:"timeHasPrefix,omitempty"`
	TimeHasSuffix    *string  `json:"timeHasSuffix,omitempty"`
	TimeIsNil        bool     `json:"timeIsNil,omitempty"`
	TimeNotNil       bool     `json:"timeNotNil,omitempty"`
	TimeEqualFold    *string  `json:"timeEqualFold,omitempty"`
	TimeContainsFold *string  `json:"timeContainsFold,omitempty"`

	// "sets" field predicates.
	Sets      *int  `json:"sets,omitempty"`
	SetsNEQ   *int  `json:"setsNEQ,omitempty"`
	SetsIn    []int `json:"setsIn,omitempty"`
	SetsNotIn []int `json:"setsNotIn,omitempty"`
	SetsGT    *int  `json:"setsGT,omitempty"`
	SetsGTE   *int  `json:"setsGTE,omitempty"`
	SetsLT    *int  `json:"setsLT,omitempty"`
	SetsLTE   *int  `json:"setsLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt             *string  `json:"createdAt,omitempty"`
	CreatedAtNEQ          *string  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn           []string `json:"createdAtIn,omitempty"`
	CreatedAtNotIn        []string `json:"createdAtNotIn,omitempty"`
	CreatedAtGT           *string  `json:"createdAtGT,omitempty"`
	CreatedAtGTE          *string  `json:"createdAtGTE,omitempty"`
	CreatedAtLT           *string  `json:"createdAtLT,omitempty"`
	CreatedAtLTE          *string  `json:"createdAtLTE,omitempty"`
	CreatedAtContains     *string  `json:"createdAtContains,omitempty"`
	CreatedAtHasPrefix    *string  `json:"createdAtHasPrefix,omitempty"`
	CreatedAtHasSuffix    *string  `json:"createdAtHasSuffix,omitempty"`
	CreatedAtEqualFold    *string  `json:"createdAtEqualFold,omitempty"`
	CreatedAtContainsFold *string  `json:"createdAtContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "workout_logs" edge predicates.
	HasWorkoutLogs     *bool                   `json:"hasWorkoutLogs,omitempty"`
	HasWorkoutLogsWith []*WorkoutLogWhereInput `json:"hasWorkoutLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkoutWhereInput) AddPredicates(predicates ...predicate.Workout) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkoutWhereInput filter on the WorkoutQuery builder.
func (i *WorkoutWhereInput) Filter(q *WorkoutQuery) (*WorkoutQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkoutWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkoutWhereInput is returned in case the WorkoutWhereInput is empty.
var ErrEmptyWorkoutWhereInput = errors.New("ent: empty predicate WorkoutWhereInput")

// P returns a predicate for filtering workouts.
// An error is returned if the input is empty or invalid.
func (i *WorkoutWhereInput) P() (predicate.Workout, error) {
	var predicates []predicate.Workout
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workout.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workout, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workout.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workout, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workout.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workout.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workout.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workout.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workout.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workout.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workout.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workout.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workout.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, workout.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, workout.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, workout.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, workout.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, workout.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, workout.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, workout.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, workout.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, workout.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, workout.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, workout.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, workout.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, workout.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, workout.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, workout.NameContainsFold(*i.NameContainsFold))
	}
	if i.Volume != nil {
		predicates = append(predicates, workout.VolumeEQ(*i.Volume))
	}
	if i.VolumeNEQ != nil {
		predicates = append(predicates, workout.VolumeNEQ(*i.VolumeNEQ))
	}
	if len(i.VolumeIn) > 0 {
		predicates = append(predicates, workout.VolumeIn(i.VolumeIn...))
	}
	if len(i.VolumeNotIn) > 0 {
		predicates = append(predicates, workout.VolumeNotIn(i.VolumeNotIn...))
	}
	if i.VolumeGT != nil {
		predicates = append(predicates, workout.VolumeGT(*i.VolumeGT))
	}
	if i.VolumeGTE != nil {
		predicates = append(predicates, workout.VolumeGTE(*i.VolumeGTE))
	}
	if i.VolumeLT != nil {
		predicates = append(predicates, workout.VolumeLT(*i.VolumeLT))
	}
	if i.VolumeLTE != nil {
		predicates = append(predicates, workout.VolumeLTE(*i.VolumeLTE))
	}
	if i.Reps != nil {
		predicates = append(predicates, workout.RepsEQ(*i.Reps))
	}
	if i.RepsNEQ != nil {
		predicates = append(predicates, workout.RepsNEQ(*i.RepsNEQ))
	}
	if len(i.RepsIn) > 0 {
		predicates = append(predicates, workout.RepsIn(i.RepsIn...))
	}
	if len(i.RepsNotIn) > 0 {
		predicates = append(predicates, workout.RepsNotIn(i.RepsNotIn...))
	}
	if i.RepsGT != nil {
		predicates = append(predicates, workout.RepsGT(*i.RepsGT))
	}
	if i.RepsGTE != nil {
		predicates = append(predicates, workout.RepsGTE(*i.RepsGTE))
	}
	if i.RepsLT != nil {
		predicates = append(predicates, workout.RepsLT(*i.RepsLT))
	}
	if i.RepsLTE != nil {
		predicates = append(predicates, workout.RepsLTE(*i.RepsLTE))
	}
	if i.Time != nil {
		predicates = append(predicates, workout.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, workout.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, workout.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, workout.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, workout.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, workout.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, workout.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, workout.TimeLTE(*i.TimeLTE))
	}
	if i.TimeContains != nil {
		predicates = append(predicates, workout.TimeContains(*i.TimeContains))
	}
	if i.TimeHasPrefix != nil {
		predicates = append(predicates, workout.TimeHasPrefix(*i.TimeHasPrefix))
	}
	if i.TimeHasSuffix != nil {
		predicates = append(predicates, workout.TimeHasSuffix(*i.TimeHasSuffix))
	}
	if i.TimeIsNil {
		predicates = append(predicates, workout.TimeIsNil())
	}
	if i.TimeNotNil {
		predicates = append(predicates, workout.TimeNotNil())
	}
	if i.TimeEqualFold != nil {
		predicates = append(predicates, workout.TimeEqualFold(*i.TimeEqualFold))
	}
	if i.TimeContainsFold != nil {
		predicates = append(predicates, workout.TimeContainsFold(*i.TimeContainsFold))
	}
	if i.Sets != nil {
		predicates = append(predicates, workout.SetsEQ(*i.Sets))
	}
	if i.SetsNEQ != nil {
		predicates = append(predicates, workout.SetsNEQ(*i.SetsNEQ))
	}
	if len(i.SetsIn) > 0 {
		predicates = append(predicates, workout.SetsIn(i.SetsIn...))
	}
	if len(i.SetsNotIn) > 0 {
		predicates = append(predicates, workout.SetsNotIn(i.SetsNotIn...))
	}
	if i.SetsGT != nil {
		predicates = append(predicates, workout.SetsGT(*i.SetsGT))
	}
	if i.SetsGTE != nil {
		predicates = append(predicates, workout.SetsGTE(*i.SetsGTE))
	}
	if i.SetsLT != nil {
		predicates = append(predicates, workout.SetsLT(*i.SetsLT))
	}
	if i.SetsLTE != nil {
		predicates = append(predicates, workout.SetsLTE(*i.SetsLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workout.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workout.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workout.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workout.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workout.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workout.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workout.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workout.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtContains != nil {
		predicates = append(predicates, workout.CreatedAtContains(*i.CreatedAtContains))
	}
	if i.CreatedAtHasPrefix != nil {
		predicates = append(predicates, workout.CreatedAtHasPrefix(*i.CreatedAtHasPrefix))
	}
	if i.CreatedAtHasSuffix != nil {
		predicates = append(predicates, workout.CreatedAtHasSuffix(*i.CreatedAtHasSuffix))
	}
	if i.CreatedAtEqualFold != nil {
		predicates = append(predicates, workout.CreatedAtEqualFold(*i.CreatedAtEqualFold))
	}
	if i.CreatedAtContainsFold != nil {
		predicates = append(predicates, workout.CreatedAtContainsFold(*i.CreatedAtContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, workout.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, workout.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, workout.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, workout.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, workout.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, workout.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, workout.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, workout.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, workout.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, workout.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, workout.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, workout.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, workout.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, workout.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, workout.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, workout.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, workout.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, workout.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, workout.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, workout.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, workout.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, workout.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, workout.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, workout.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, workout.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, workout.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, workout.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, workout.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, workout.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, workout.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, workout.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, workout.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, workout.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, workout.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, workout.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, workout.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, workout.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, workout.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, workout.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, workout.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, workout.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, workout.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, workout.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasUsers != nil {
		p := workout.HasUsers()
		if !*i.HasUsers {
			p = workout.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workout.HasUsersWith(with...))
	}
	if i.HasWorkoutLogs != nil {
		p := workout.HasWorkoutLogs()
		if !*i.HasWorkoutLogs {
			p = workout.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkoutLogsWith) > 0 {
		with := make([]predicate.WorkoutLog, 0, len(i.HasWorkoutLogsWith))
		for _, w := range i.HasWorkoutLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkoutLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workout.HasWorkoutLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkoutWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workout.And(predicates...), nil
	}
}

// WorkoutLogWhereInput represents a where input for filtering WorkoutLog queries.
type WorkoutLogWhereInput struct {
	Predicates []predicate.WorkoutLog  `json:"-"`
	Not        *WorkoutLogWhereInput   `json:"not,omitempty"`
	Or         []*WorkoutLogWhereInput `json:"or,omitempty"`
	And        []*WorkoutLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt             *string  `json:"createdAt,omitempty"`
	CreatedAtNEQ          *string  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn           []string `json:"createdAtIn,omitempty"`
	CreatedAtNotIn        []string `json:"createdAtNotIn,omitempty"`
	CreatedAtGT           *string  `json:"createdAtGT,omitempty"`
	CreatedAtGTE          *string  `json:"createdAtGTE,omitempty"`
	CreatedAtLT           *string  `json:"createdAtLT,omitempty"`
	CreatedAtLTE          *string  `json:"createdAtLTE,omitempty"`
	CreatedAtContains     *string  `json:"createdAtContains,omitempty"`
	CreatedAtHasPrefix    *string  `json:"createdAtHasPrefix,omitempty"`
	CreatedAtHasSuffix    *string  `json:"createdAtHasSuffix,omitempty"`
	CreatedAtEqualFold    *string  `json:"createdAtEqualFold,omitempty"`
	CreatedAtContainsFold *string  `json:"createdAtContainsFold,omitempty"`

	// "exercise_id" field predicates.
	ExerciseID             *string  `json:"exerciseID,omitempty"`
	ExerciseIDNEQ          *string  `json:"exerciseIDNEQ,omitempty"`
	ExerciseIDIn           []string `json:"exerciseIDIn,omitempty"`
	ExerciseIDNotIn        []string `json:"exerciseIDNotIn,omitempty"`
	ExerciseIDGT           *string  `json:"exerciseIDGT,omitempty"`
	ExerciseIDGTE          *string  `json:"exerciseIDGTE,omitempty"`
	ExerciseIDLT           *string  `json:"exerciseIDLT,omitempty"`
	ExerciseIDLTE          *string  `json:"exerciseIDLTE,omitempty"`
	ExerciseIDContains     *string  `json:"exerciseIDContains,omitempty"`
	ExerciseIDHasPrefix    *string  `json:"exerciseIDHasPrefix,omitempty"`
	ExerciseIDHasSuffix    *string  `json:"exerciseIDHasSuffix,omitempty"`
	ExerciseIDIsNil        bool     `json:"exerciseIDIsNil,omitempty"`
	ExerciseIDNotNil       bool     `json:"exerciseIDNotNil,omitempty"`
	ExerciseIDEqualFold    *string  `json:"exerciseIDEqualFold,omitempty"`
	ExerciseIDContainsFold *string  `json:"exerciseIDContainsFold,omitempty"`

	// "workout_id" field predicates.
	WorkoutID             *string  `json:"workoutID,omitempty"`
	WorkoutIDNEQ          *string  `json:"workoutIDNEQ,omitempty"`
	WorkoutIDIn           []string `json:"workoutIDIn,omitempty"`
	WorkoutIDNotIn        []string `json:"workoutIDNotIn,omitempty"`
	WorkoutIDGT           *string  `json:"workoutIDGT,omitempty"`
	WorkoutIDGTE          *string  `json:"workoutIDGTE,omitempty"`
	WorkoutIDLT           *string  `json:"workoutIDLT,omitempty"`
	WorkoutIDLTE          *string  `json:"workoutIDLTE,omitempty"`
	WorkoutIDContains     *string  `json:"workoutIDContains,omitempty"`
	WorkoutIDHasPrefix    *string  `json:"workoutIDHasPrefix,omitempty"`
	WorkoutIDHasSuffix    *string  `json:"workoutIDHasSuffix,omitempty"`
	WorkoutIDIsNil        bool     `json:"workoutIDIsNil,omitempty"`
	WorkoutIDNotNil       bool     `json:"workoutIDNotNil,omitempty"`
	WorkoutIDEqualFold    *string  `json:"workoutIDEqualFold,omitempty"`
	WorkoutIDContainsFold *string  `json:"workoutIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "exercises" edge predicates.
	HasExercises     *bool                 `json:"hasExercises,omitempty"`
	HasExercisesWith []*ExerciseWhereInput `json:"hasExercisesWith,omitempty"`

	// "workouts" edge predicates.
	HasWorkouts     *bool                `json:"hasWorkouts,omitempty"`
	HasWorkoutsWith []*WorkoutWhereInput `json:"hasWorkoutsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkoutLogWhereInput) AddPredicates(predicates ...predicate.WorkoutLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkoutLogWhereInput filter on the WorkoutLogQuery builder.
func (i *WorkoutLogWhereInput) Filter(q *WorkoutLogQuery) (*WorkoutLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkoutLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkoutLogWhereInput is returned in case the WorkoutLogWhereInput is empty.
var ErrEmptyWorkoutLogWhereInput = errors.New("ent: empty predicate WorkoutLogWhereInput")

// P returns a predicate for filtering workoutlogs.
// An error is returned if the input is empty or invalid.
func (i *WorkoutLogWhereInput) P() (predicate.WorkoutLog, error) {
	var predicates []predicate.WorkoutLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workoutlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WorkoutLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workoutlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WorkoutLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workoutlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workoutlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workoutlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workoutlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workoutlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workoutlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workoutlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workoutlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workoutlog.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, workoutlog.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, workoutlog.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workoutlog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workoutlog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workoutlog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workoutlog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workoutlog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workoutlog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workoutlog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workoutlog.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtContains != nil {
		predicates = append(predicates, workoutlog.CreatedAtContains(*i.CreatedAtContains))
	}
	if i.CreatedAtHasPrefix != nil {
		predicates = append(predicates, workoutlog.CreatedAtHasPrefix(*i.CreatedAtHasPrefix))
	}
	if i.CreatedAtHasSuffix != nil {
		predicates = append(predicates, workoutlog.CreatedAtHasSuffix(*i.CreatedAtHasSuffix))
	}
	if i.CreatedAtEqualFold != nil {
		predicates = append(predicates, workoutlog.CreatedAtEqualFold(*i.CreatedAtEqualFold))
	}
	if i.CreatedAtContainsFold != nil {
		predicates = append(predicates, workoutlog.CreatedAtContainsFold(*i.CreatedAtContainsFold))
	}
	if i.ExerciseID != nil {
		predicates = append(predicates, workoutlog.ExerciseIDEQ(*i.ExerciseID))
	}
	if i.ExerciseIDNEQ != nil {
		predicates = append(predicates, workoutlog.ExerciseIDNEQ(*i.ExerciseIDNEQ))
	}
	if len(i.ExerciseIDIn) > 0 {
		predicates = append(predicates, workoutlog.ExerciseIDIn(i.ExerciseIDIn...))
	}
	if len(i.ExerciseIDNotIn) > 0 {
		predicates = append(predicates, workoutlog.ExerciseIDNotIn(i.ExerciseIDNotIn...))
	}
	if i.ExerciseIDGT != nil {
		predicates = append(predicates, workoutlog.ExerciseIDGT(*i.ExerciseIDGT))
	}
	if i.ExerciseIDGTE != nil {
		predicates = append(predicates, workoutlog.ExerciseIDGTE(*i.ExerciseIDGTE))
	}
	if i.ExerciseIDLT != nil {
		predicates = append(predicates, workoutlog.ExerciseIDLT(*i.ExerciseIDLT))
	}
	if i.ExerciseIDLTE != nil {
		predicates = append(predicates, workoutlog.ExerciseIDLTE(*i.ExerciseIDLTE))
	}
	if i.ExerciseIDContains != nil {
		predicates = append(predicates, workoutlog.ExerciseIDContains(*i.ExerciseIDContains))
	}
	if i.ExerciseIDHasPrefix != nil {
		predicates = append(predicates, workoutlog.ExerciseIDHasPrefix(*i.ExerciseIDHasPrefix))
	}
	if i.ExerciseIDHasSuffix != nil {
		predicates = append(predicates, workoutlog.ExerciseIDHasSuffix(*i.ExerciseIDHasSuffix))
	}
	if i.ExerciseIDIsNil {
		predicates = append(predicates, workoutlog.ExerciseIDIsNil())
	}
	if i.ExerciseIDNotNil {
		predicates = append(predicates, workoutlog.ExerciseIDNotNil())
	}
	if i.ExerciseIDEqualFold != nil {
		predicates = append(predicates, workoutlog.ExerciseIDEqualFold(*i.ExerciseIDEqualFold))
	}
	if i.ExerciseIDContainsFold != nil {
		predicates = append(predicates, workoutlog.ExerciseIDContainsFold(*i.ExerciseIDContainsFold))
	}
	if i.WorkoutID != nil {
		predicates = append(predicates, workoutlog.WorkoutIDEQ(*i.WorkoutID))
	}
	if i.WorkoutIDNEQ != nil {
		predicates = append(predicates, workoutlog.WorkoutIDNEQ(*i.WorkoutIDNEQ))
	}
	if len(i.WorkoutIDIn) > 0 {
		predicates = append(predicates, workoutlog.WorkoutIDIn(i.WorkoutIDIn...))
	}
	if len(i.WorkoutIDNotIn) > 0 {
		predicates = append(predicates, workoutlog.WorkoutIDNotIn(i.WorkoutIDNotIn...))
	}
	if i.WorkoutIDGT != nil {
		predicates = append(predicates, workoutlog.WorkoutIDGT(*i.WorkoutIDGT))
	}
	if i.WorkoutIDGTE != nil {
		predicates = append(predicates, workoutlog.WorkoutIDGTE(*i.WorkoutIDGTE))
	}
	if i.WorkoutIDLT != nil {
		predicates = append(predicates, workoutlog.WorkoutIDLT(*i.WorkoutIDLT))
	}
	if i.WorkoutIDLTE != nil {
		predicates = append(predicates, workoutlog.WorkoutIDLTE(*i.WorkoutIDLTE))
	}
	if i.WorkoutIDContains != nil {
		predicates = append(predicates, workoutlog.WorkoutIDContains(*i.WorkoutIDContains))
	}
	if i.WorkoutIDHasPrefix != nil {
		predicates = append(predicates, workoutlog.WorkoutIDHasPrefix(*i.WorkoutIDHasPrefix))
	}
	if i.WorkoutIDHasSuffix != nil {
		predicates = append(predicates, workoutlog.WorkoutIDHasSuffix(*i.WorkoutIDHasSuffix))
	}
	if i.WorkoutIDIsNil {
		predicates = append(predicates, workoutlog.WorkoutIDIsNil())
	}
	if i.WorkoutIDNotNil {
		predicates = append(predicates, workoutlog.WorkoutIDNotNil())
	}
	if i.WorkoutIDEqualFold != nil {
		predicates = append(predicates, workoutlog.WorkoutIDEqualFold(*i.WorkoutIDEqualFold))
	}
	if i.WorkoutIDContainsFold != nil {
		predicates = append(predicates, workoutlog.WorkoutIDContainsFold(*i.WorkoutIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, workoutlog.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, workoutlog.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, workoutlog.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, workoutlog.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, workoutlog.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, workoutlog.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, workoutlog.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, workoutlog.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, workoutlog.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, workoutlog.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, workoutlog.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, workoutlog.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, workoutlog.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, workoutlog.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, workoutlog.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasUsers != nil {
		p := workoutlog.HasUsers()
		if !*i.HasUsers {
			p = workoutlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workoutlog.HasUsersWith(with...))
	}
	if i.HasExercises != nil {
		p := workoutlog.HasExercises()
		if !*i.HasExercises {
			p = workoutlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExercisesWith) > 0 {
		with := make([]predicate.Exercise, 0, len(i.HasExercisesWith))
		for _, w := range i.HasExercisesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExercisesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workoutlog.HasExercisesWith(with...))
	}
	if i.HasWorkouts != nil {
		p := workoutlog.HasWorkouts()
		if !*i.HasWorkouts {
			p = workoutlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkoutsWith) > 0 {
		with := make([]predicate.Workout, 0, len(i.HasWorkoutsWith))
		for _, w := range i.HasWorkoutsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkoutsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workoutlog.HasWorkoutsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkoutLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workoutlog.And(predicates...), nil
	}
}
